title: qctf-mips
date: 1970-1-1
categories:
- 二进制
---
## 题目分析
- 分析代码,首先是第一个函数(简单异或,操作以后和一个长度为5的字符串作比较
- 比较通过后,进入下一个函数,再次处理后27字符,后发现函数根据i&1的返回值分开了执行顺序,即奇偶分开加密
- 两端代码极其相似(一开始我弄没做出来,看了好久才发现= =)
- 实际上这两个操作是一个可逆的高低位互换(高二低六)
- 放出
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ida.h"
int main(){
    unsigned char a[32] = {81,124,106,123,103,82, 253,  22, 164, 137, 189, 146, 128,  19,  65, 
   84, 160, 141,  69,  24, 129, 222, 252, 149, 240, 
   22, 121,  26,  21,  91, 117,  31};
    int i,j,x,y;
    for(i=5;i<32;i++){
        if((i&1)!=0){
            a[i] = ((a[i]<<2)&0xff)|((a[i]>>6)&0xff);
        }
        else{
            a[i] = ((a[i]>>2)&0xff)|((a[i]<<6)&0xff);
        }
    }
    for(i=0;i<32;i++){
        a[i]^=(32-i);
    }
    for(i=0;i<32;i++){
        printf("%c",a[i]);
    }
}
```
## mips总结
- 一般的mips最好还是对照着汇编耐心分析(这种需要硬怼汇编的题一定要有耐心啊,无论是这种还是vm,主要是分析稍微繁琐,但是思路都不会没有的
- 指令中类似于$v0, 0($v0)的,括号中为基址,外面的数字为偏移
- lw <=相反=> sw
- 其余还要记住一些算法的特征常量
- 耐心怼还是最重要的