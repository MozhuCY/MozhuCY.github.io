---
title: 内存虚拟化
date: 2020-02-28 18:21:40
tags: PWN
---

# 传统的内存管理

众所周知,在调试一个程序的时候,会经常发现一些代码处在0x401000处,尽管我们同时调试两个程序,但是他们的内存还是有重合的地方,这里就涉及到了虚拟内存的问题.

为了提高内存的使用率,避免造成内存浪费,并且解决程序间互相干扰的问题,CPU引入了分页和分段的机制,当前时代的CPU存在两种模式,分别是`实模式`和`保护模式`,值得注意的是,在实模式中,所有的地址都是物理地址,并且都是具有RWX权限的,在进入新时代后,对于计算的需求不断提高,所以保护模式就产生了

实模式中对于地址的概念,也就是在微机原理中所学到的概念,例如`cs:ip`,我们在寻址时,实际上访问的是`$cs*0x10+$ip`,并且在实模式中,计算机是没有内存之前的区分的,也没有权限管理.

而在保护模式中,对于地址的概念就不同了,这时以为CPU引入了分段和分页技术,所以对于地址的一些计算也就发生了变化,最明显的是我们有了下面几个概念

- 逻辑地址/虚拟地址:处于保护模式下的CPU的地址,例如用户态应用访问的0x401000
- 线性地址:由于开启了分段机制,所以从逻辑地址,进行分段的转换,所计算得到的地址,就为线性地址,若未开启分页机制,则此地址就为物理地址.
- 物理地址:在开启了分页机制后,对于利用页表对于线性地址转换后得到的地址,即为物理地址.

在80386处理器中,我们以保护模式来说,虽然不是同一时间,还是同一个指令,今天继续来分析`cs:eip`的含义,在这里对应的地址并不是像实模式一样,进行简单的代数运算,继续来说一下内核中才会用到的寄存器CR0,这里着重介绍一下CR0中的两个保护控制位PE/PG

- PE:启动保护(Protection Enable)标志,当设置该位时,就开启了保护模式,当复位时,就恢复了实模式.
- PG:分页(Paging)标志,档次为开启是,就开启了分页机制,复位时,禁止分页机制,此时线性地址就为物理地址.此位仅在PE开启时才有效.

也就是说,我们假设PE=PG=1,那么我们来继续分析`CS:EIP`的含义,在段寄存器中,实际上包含了两个部分,分别是**可见部分**和**不可见部分**,因为在段的管理过程中,涉及到了段的基址,段的属性,段的大小.所以其实我们平时可以看到的是被称作为**段选择符**的部分.

![](内存虚拟化/1.png)

![](内存虚拟化/2.png)

其中TI表示的是GDTR和LDTR的选择,而RPL则表示特权级(ring0-ring3).

```C
Struct SegMent
{
    WORD Selector;     //16位段选择子
    WORD Attributes; //16位属性
    DWORD Base；     //32位基址
    DWORD Limit；    //32位段限长
}
```

而隐藏部分,我们又把它称作影子寄存器,其实他是一个缓冲,在加载描述符索引时,同时为了减少CPU的访问DT的次数.CPU会将段描述符解析加载到影子寄存器中.

![](内存虚拟化/3.png)

也就是这里存放着的描述符.

![](内存虚拟化/4.png)

也就是说,在计算线性地址时,是这个样子的,具体参考下图

![](内存虚拟化/5.png)

涉及到的寄存器有GDTR,CR3,CR0,LDTR.

对于GDT和LDT的不同之处,可以理解为LDT其实就是一个二级Description Table,LDTR其实存着的东西和GDT不同,类似段寄存器,LDTR的目的是选择出GDT中的LDT的段描述符,然后计算LDT的地址,再由段寄存器计算

![](内存虚拟化/6.png)

再来说一下mmap,mmap这个系统调用应该也是比较常见的,它一般被用来从文件中映射到一段内存,用户对内存的操作就等于对文件的操作,一般来说,mmap的性能是高于read/write的,因为他们的底层机制是不同的.

在mmap一段内存时,系统做的仅仅是申请了一段对应大小的虚拟内存,并没有将其与物理内存相关联,当我们第一次操作内存的时候,MMU计算后会访问到物理内存,也就是物理页,由于是第一次访问,所以没有进行初始化,会发生缺页中断,然后转到内核处理,这时系统才会真的把文件内容加载到物理内存中

而read/write,其实是对于文件数据进行了两次拷贝,第一次是从文件拷贝到内核的缓冲区,第二次是拷贝到用户态,比mmap多了一次,所以效率自然就慢了.

mmap还存在两种调用方式,分别是有backend和无backend,fd参数决定了这个,当fd是一个正常的文件描述符时,mmap处于有backend模式.此时对于mod来说,又分了两种情况

- **MAP_SHARED**:此时对于文件的操作,实际上是对于进程间可见的,因为对于同一块物理内存,实际上是相同的
- **MAP_PRIVATE**:此时是一个COW机制,在对于内存读写时,实际上操作的是一个复制到缓存中的副本,而不是实际上的物理地址中的数据,如果不主动释放这个区域,会造成内存耗尽,被OOM(Out Of Memory killer)机制杀死.并且最后的数据是不会写写回文件的.

无backend模式就是fd参数无效,并且mod为MAP_ANONYMOUS,此时的内存是由内核所创建的,将内存映射到一个匿名文件,这种情况同样需要我们手动去释放,不然也会触发OOM Killer.

# QEMU的内存虚拟化

在QEMU中,我们涉及到了许多个层面的地址

虚拟机虚拟地址->虚拟机线性地址->虚拟机物理地址->宿主机虚拟地址->宿主机线性地址->宿主机物理地址

或者说是`GVA->GPA->HVA->HPA`.可以看到光是地址之间的转换,就涉及到了很多步计算,那么在虚拟化的过程中,每一次的读写地址,都会涉及到巨大的转换量,造成性能的损耗.所以这时必须实现高效的内存虚拟化.



.....先收工