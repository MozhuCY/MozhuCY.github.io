title: hctf2018-部分逆向wp(Spiral是真的做不来)
date: 1970-1-1
categories:
- RE
---

- 感谢杭电师傅们举办的hctf.题目质量还是依旧的高,也学到了很多东西,特别是windows逆向部分,感觉自己需要学的太多了,给师傅们跪了Orz
- 比赛那几天真的是没什么心思做题,赛后来凑个热闹吧..

# seven

- 这个题比较简单,是一个驱动逆向,具体的实现算法就是一个maze一样的7,程序利用键盘扫描码WASD来进行在地图中移动
- 顺带学一下驱动逆向,DriverEntry就是驱动的一个入口,一般的作用是初始化驱动程序,定位/申请资源,创建内核对象
- _security_init_cookie函数其实就是windows中的一个与栈保护机制相关的函数,类似与canary,在函数帧栈中,该cookie在ebp的上面
- 然后程序分配了一块内存并且分配了三个函数指针,进行初始化等操作,其中有个函数存放了check函数的函数指针最后到达函数sub_140001000

# LuckyStar

- Ch1p师傅的题,我觉得这个题的出题思路和实现姿势比我上次出的那个自修改强了许多,借这道题好好学习一波=v=
- 首先要提的是题目中的tls回调函数,一般在程序中,新建线程(包括主线程)和结束进程时都会调用执行的函数.在这个tls回调函数里,实现了反调试以及GetProcAddress
- 随后是一个lstrcmpW的字符串数组比较的反调试,过滤了od,ida等绝大多数调试器,如果检测到调试器的挂载,那么程序退出,否则利用srand(0x61616161)定义随机数种子,smc解密一个函数401780
- 这个函数首先是在播放一个很奇怪很奇怪的歌曲,播放结束后,程序继续进行下去,这里又是一个smc解密另一个函数4015e0,这时我想通过0x61616161的后续rand值来进行异或修改,但是没能成功,一直在想是不是tls函数被调用了许多次,rand在后面,经过一连串的后续爆破等操作,还是没能解出4015e0函数的内容,但是程序运行是的确可以运行的,输入的字符串经过加密函数以后,和内存中的一个数组进行字符串比较
- 所以现在需要拿到那个函数的smc解密后的东西,这里使用attach来附加进程,当歌曲播放结束以后,利用ida attach到进程,利用快捷键g跳到4015e0函数,cp创建函数之后f5
- 算法很清晰了,一个table被改过的base64函数,一个随机数异或,整理出来的伪代码是这个样子

```c
srand(xxxxxx);
base64encode(input);
for(i = 0;i < 32; i++){
    for(j = 0;j < 4; j++){
        input[i] ^= rand()%4 << 2*(3 - j);
    }
}
```

- 可以使用黑盒测试打出异或的数组,只要attach到程序上以后,在enc函数中下好断点后继续运行程序,就能断在函数里面,当统计好异或的轮数后(或者后续手动更改0x1d),运行程序,从栈内就可以拿到异或数组了

```python
b = [73, 230, 87, 189, 58, 71, 17, 76, 149, 188, 238, 50, 114, 160, 240, 222, 172, 242, 131, 86, 131, 73, 110, 169, 166, 197, 103, 60, 202, 200, 204, 5]
a = [8, 129, 57, 141, 64, 9, 66, 20, 208, 242, 152, 102, 51, 214, 201, 178, 193, 149, 182, 30, 199, 45, 28, 239, 210, 178, 95, 102, 140, 185, 241, 56, 20, 8, 143, 206, 233, 127, 13, 5]
for i in range(len(b)):
    b[i] ^= a[i]
flag = ""

def aa(i):
    if 95 <= i <= 122:
        i -= 32
    elif 65 <= i <= 90:
        i += 32
    else:
        pass
    return chr(i) 

for i in range(len(b)):
    flag += aa(b[i])

print flag.decode("base64")
```

# PolishDuck

- 去百度了一下题目中的字符串Arduino Leonardo,发现是BadUSB的开发板.
- 大概了解了一下BadUSB,BadUSB插入电脑后,会模拟键盘鼠标等设备对攻击电脑进行操作,从而达成对目标电脑进行的一系列攻击
- 开发BadUSB时,需要一个leonardo Arduino开发板和一个Arduino IDE,那么这个文件很容易就能看出来实际上就是从BadUSB中dump出来的一个二进制文件
- 
